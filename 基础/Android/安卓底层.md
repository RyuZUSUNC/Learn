# 引用
- https://zh.wikipedia.org/wiki/Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA
- https://zh.wikipedia.org/wiki/Android_Runtime

# Dalvik虚拟机
## 简述
这是一种由谷歌等厂商合作开发的安卓核心组成之一，其运行的软件也是JAVA应用程序，但软件的格式为dex，即Dalvik Executable格式。dex格式是专门为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。

Dalvik由Dan Bornstein编写的，名字来源于他的祖先曾经居住过的小渔村达尔维克（Dalvík），位于冰岛埃亚峡湾。

与JVM这种堆栈机器不同的是，Dalvik虚拟机是一种寄存器机，两种架构各有优劣，通常来说，堆栈机器需要更多指令，而寄存器机器需要的指令虽然不多，但是更长。

从安卓5.0起，ART(Android Runtime)取代Dalvik成为系统内默认的虚拟机。

## 架构
对于Dalvik虚拟机来说，只能运行dex格式的文件，这时候就需要将java class通过dx工具转换成dex格式，与jar不同的是，多个java class 被包含在一个dex文件中，dex文件中各个重复的字符串和其他常量只在DEX中存放一次，以节省空间。

Java字节码（bytecode）被转换成Dalvik虚拟机所使用的替代指令集。一般来说，一个未压缩的dex文件通常要小于一个已经压缩的jar文件。

当安卓启动时，Dalvik虚拟机监视所有的应用程序(APK)，并且创建依存关系树，为每个程序优化代码并存储在Dalvik虚拟机缓存中。Dalvik第一次加载后会生成Cache文件，以提供下次快速加载，所以会有安卓设备第一次启动很慢的情况出现。

## dx工具
dx工具可以将Java class转换成dex格式。一个dex文件通常会有多个class。由于dex有时必须进行优化，会使文件大小增加1-4倍，以ODEX结尾。

## 差异
- Dalvik虚拟机早期并没有使用即时编译（JIT）技术。从Android 2.2开始，Dalvik虚拟机也支持JIT。
- Dalvik虚拟机有自己的字节码，并非使用Java字节码。
- Dalvik基于寄存器，而JVM基于堆栈。
- Dalvik VM透过Zygote进行类别的预加载，Zygote会完成虚拟机的初始化，也是与JVM不同之处。

# ART虚拟机

Android Runtime（缩写为ART），是一种在Android操作系统上的运行环境，由Google公司研发，并在2013年作为Android 4.4系统中的一项测试功能正式对外发布，在Android 5.0及后续Android版本中作为正式的运行时库取代了以往的Dalvik虚拟机。ART能够把应用程序的字节码转换为机器码，是Android所使用的一种新的虚拟机。它与Dalvik的主要不同在于：Dalvik采用的是JIT技术，而ART采用Ahead-of-time（AOT）技术。ART同时也改善了性能、垃圾回收（Garbage Collection）、应用程序出错以及性能分析。

JIT最早在Android 2.2系统中引进到Dalvik虚拟机中，在应用程序启动时，JIT通过进行连续的性能分析来优化程序代码的执行，在程序运行的过程中，Dalvik虚拟机在不断的进行将字节码编译成机器码的工作。

与Dalvik虚拟机不同的是，ART引入了AOT这种预编译技术，在应用程序安装的过程中，ART就已经将所有的字节码重新编译成了机器码。应用程序运行过程中无需进行实时的编译工作，只需要进行直接调用。因此，ART极大的提高了应用程序的运行效率，同时也减少了手机的电量消耗，提高了移动设备的续航能力，在垃圾回收等机制上也有了较大的提升。

为了保证向下兼容，ART使用了相同的Dalvik字节码文件（dex），即在应用程序目录下保留了dex文件供旧程序调用，然而.odex文件则替换成了可执行与可链接格式（ELF）可执行文件。一旦一个程序被ART的dex2oat命令编译，那么这个程序将会指通过ELF可执行文件来运行。

因此，相对于Dalvik虚拟机模式，ART模式下Android应用程序的安装需要消耗更多的时间，同时也会占用更大的内部储存空间，用于储存编译后的代码，但节省了很多Dalvik虚拟机用于实时编译的时间。

Google公司在Android 4.4中带来的ART模式仅仅是ART的一个预览版，系统默认仍然使用的是Dalvik虚拟机，4.4上面提供的预览版ART相对于Android 5.0以后的ART运行时库有较大的不同，尤其体现在兼容性上。

# JIT(Just-in-time compilation)
即时编译（英语：Just-in-time compilation，缩写：JIT），又译及时编译、实时编译，动态编译的一种形式，是一种提高程序运行效率的方法。通常，程序有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，而解释执行的则是一句一句边运行边翻译。

即时编译器则混合了这二者，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。相对于静态编译代码，即时编译的代码可以处理延迟绑定并增强安全性。

即时编译器有两种类型，一是字节码翻译，二是动态编译翻译。

微软的.NET Framework，还有绝大多数的Java实现，都依赖即时编译以提供高速的代码执行。Mozilla Firefox使用的JavaScript引擎SpiderMonkey也用到了JIT的技术。Ruby的第三方实现Rubinius和Python的第三方实现PyPy也都通过JIT来明显改善了解释器的性能。

# AOT(Ahead-of-time)
## 减小运行开销
某些具有托管代码运行时且可以编译为中间表示形式的编程语言，使用即时（JIT）编译。简而言之，这会将中间代码编译为机器代码，以便在中间代码执行时进行本机运行，这可能会降低应用程序的性能。提前编译可以在执行之前而不是执行期间进行操作，从而无需执行此步骤。

在大多数情况下，使用完全AOT编译的程序和库，可以删除运行时环境的有用部分，从而节省磁盘空间，内存，电池寿命和启动时间（无JIT预热阶段）等。因此，它在嵌入式或移动设备中很有用。

## 性能折中
AOT编译器可以执行复杂和高级的代码优化，在大多数情况下，JITing会被认为过于昂贵。相反，AOT通常无法在JIT中执行某些可能的优化，例如运行时配置文件引导的优化（PGO），伪常量传播或间接虚拟函数 内联。

此外，JIT编译器可以通过对代码进行假设来推测性地优化热代码。如果以后的推测假设证明是错误的，则可以对生成的代码进行优化。这样的操作会减慢正在运行的软件的性能，直到通过自适应优化再次优化代码为止。AOT编译器无法做出这样的假设，因此需要在编译时推断尽可能多的信息。它需要求助于不太专业的代码，因为它不知道哪种类型的方法会通过。这些问题可以通过配置文件引导的优化来缓解。但是即使在这种情况下，生成的代码也无法像JIT编译器那样动态地适应不断变化的运行时配置文件。

# dex文件(dalvik executable文件)


# smali语法/文件

