# 第一章
## 计算机系统的基本组成

**基本思想/结构特点**

1. 使用“存储程序”工作方式
2. 计算机由运算器,控制器,存储器,输入设备和输出设备5个基本部件组成
3. 存储器不仅能存放数据,而且也能存放指令,形式上数据和指令没什么区别,但计算机能区分它们; 控制器应能控制指令的自动执行; 运算器应能进行加减乘除四种基本算数运算,并且也能进行逻辑运算; 操作人员可以通过输入输出设备使用计算机
4. 计算机内部以二进制形式表达指令和数据; 每条指令由操作码和地址码两部分组成,操作码指出操作类型,地址码指出操作数的地址; 由一串指令组成程序

`硬件`: 计算机硬件主要包括中央处理器,存储器,I/O控制器,外部设备和总线等,是物理装置的总称

`软件`: 运行在硬件上的程序和数据以及相关的文档

`程序`: 是指挥计算机如何操作的一个**指令序列**,即程序由指令组成

`指令`: 是计算机硬件能够直接理解并执行的最**基本操作**

`数据`: 是指令操作的对象

`存储程序方式`: 将编制好的程序（由若干相应的指令构成）存入计算机的存储器,当计算机工作时,能自动的逐条取出指令并执行

`IAS计算机`: “存储程序” 计算机

**现代计算机的基本组成:**

硬件部分: 

- `中央处理器`（Central Processing Unit,CPU）有时简称为处理器,是整个计算机的核心部件,主要用于指令的执行。CPU主要包含两种基本部件**数据通路**和**控制器**。

  - `数据通路`主要包含**算数逻辑部件(ALU)**和**通用寄存器**等,其功能是用来执行算数和逻辑运算等操作。

  - `控制器`用来对指令进行**译码**,生成相应的控制信号,以控制数据通路进行正确的操作

- `存储器`分为**内存**和**外存**,
  
  - `内存`包括`主存储器`(main memory,简称主存)和`高速缓存`(cache)

  - `外存`包括`辅助存储器`和`海量后备存储器`.通常把系统运行时直接和主存交换信息的存储器称为辅助存储器,简称辅存,目前主要的辅助存储器是磁盘存储器和固态硬盘

- `外部设备`简称为外设,也成为`I/O设备`,I/O是输入输出(Input/Output)的缩写.外设通常由机械部分和电子部分组成,而且两部分通常是可以分开的,机械部分是外部设备本身,而电子部分则是控制外部设备的`I/O控制器或I/O适配器`,外设通过`I/O控制器或I/O适配器`连接到主机上,`I/O控制器或I/O适配器`统称为设备控制器

- `总线`(bus)是传输信息的介质,用于在部件之间传输信息,CPU,主存和I/O模块通过总线互联,在CPU和I/O模块中都内涵相应的存储部件,即**缓存器**

`ALU`是数据处理部件,用于执行数据的算数和逻辑运算,ALU处理的数据来自**寄存器堆**;

`磁盘和主存`是存储部件,分别用于存储长期保存信息和临时保存信息;

`各类总线以及总线接口部件`,I/O桥接器,I/O扩展槽,I/O控制器和显示适配器等都是互联部件,用于完成数据传送任务

所有这些部件的操作都通过`CPU`中的`控制器`对指令**译码**后送出的**控制信号**的控制来完成

## 计算机软件

- 软件
  - 系统软件
    - 操作系统
    - 语言处理程序(编译器)
    - 数据库管理系统(DBMS)
    - 实用程序(磁盘碎片整理等)
  - 应用软件: 专门为某些应用比所编写的各类程序

## 计算机系统的层次结构

```
    应用(问题)
    算法
    编程(语言)
    操作系统/虚拟机
    指令集体系结构(ISA)
    微体系结构
    功能部件/RTL
    电路
    器件
```

`汇编程序(assembler)`: 也称汇编器,用来将汇编语言源程序翻译成机器语言目标程序

`解释程序(interpreter)`: 也称解释器,用来将源程序中的语句按其执行顺序逐条翻译成机器指令并立即执行

`编译程序(compiler)`: 也称编译器,用来将高级语言源程序翻译成汇编语言或机器语言目标程序

`指令集体系结构(ISA)`: 机器语言程序所运行的计算机硬件和软件之间需要有一个"桥梁",这个在软件和硬件之间的界面就是指令集体系结构(Instruction Set Architecture,ISA),简称体系结构或系统结构(architecture),他是软件和硬件之间接口的一个完整定义.ISA定义了一台计算机可以执行的所有指令的集合,每条指令规定了计算机执行什么操作,所处理的操作数存放的地址控件以及操作数类型.

`微体系结构`: ISA是对指令系统的一种规定或结构规范,具体实现的组织(organization) 称为微体系结构(microarchitecture)简称微架构. 相同的ISA可能会具有不同的微体系结构

## 计算机系统的不同用户

`最终用户`: 使用应用程序完成特定任务的计算机用户

`系统管理员`: 指利用操作系统等软件提供的功能对系统进行配置,管理和维护,以建立高效合理的系统环境供计算机用户使用的操作人员

`应用程序员`: 指使用高级编程语言编制应用软件的程序员

`系统程序员`: 指设计和开发系统软件的程序员

## 程序开发和执行过程

假设有一个 hello.c 的文件

将 hello.c 进行预处理,编译,汇编和链接,最终生成可执行目标文件.例如在UNIX系统中可用GCC编译驱动程序进行处理

```
hello.c(C源程序)   预处理程(cpp)   hello.i(预处理后的源程序)   编译程序(ccl)   hello.s(汇编源程序)   汇编程序(as)   hello.o(可重定位目标程序)   链接程序(ld)   hello(可执行目标程序)
```

## 指令执行的过程

`通用寄存器组`: 用来存放操作数或操作数的地址

`标志寄存器`: 用来存放ALU运算得到的一些标志信息

`程序计数器(PC)`: 用来存放将要执行的下一条指令的地址

`指令寄存器(IR)`: 用来存放从主存中读出的指令

`主存地址`: 每个存储但愿的一个唯一编号

`存储地址寄存器(MAR,memory access register)`: 用来存放当前CPU所访问的内存单元的地址

`存储数据寄存器(MDR,memory data register)`: 用来存放CPU与主存储器交换的数据

可执行目标文件中包含机器代码段

机器代码段由一条一条指令构成

程序被启动后,CPU通过逐条执行程序中的指令来实现程序的功能

**执行过程**

1. 根据PC取指令到IR
2. 指令译码并送出控制信号
3. 取操作数
4. 执行指令
5. 写回结果

PC更新: 为了能自动执行程序中的指令 CPU必须能够自动得到下一条指令的地址并送PC,所以取出指令送到IR稳定后,PC自动更新

定长指令字系统: 每条指令的长度都一样
          PC = PC + 指令长度(相同值)

变长指令字系统: 每条指令的长度不一样
          PC = PC + 指令长度(不同值)

`指令周期`: 从一条指令的启动到下一条指令的启动之间的间隔时间 

`机器周期`: 是指令执行中每一步操作所需的时间.一般以CPU中完成一个原运算操作所需的时间作为机器周期的基本时间,机器周期也叫CPU周期

`时钟周期`: 指计算机的主频周期,也成为T周期或T状态

## 计算机系统性能评价

`吞吐率(带宽)`: 表示在单位时间内所完成的工作量
`响应时间(执行时间或等待时间)`: 是指从作业提交开始到作业完成所需要的时间

`CPU时间`: 指CPU用于程序执行的时间,包括用户CPU时间和系统CPU时间
  - 用户CPU时间: 指真正用于运行用户程序代码的时间
  - 系统CPU时间: 指为了执行用户程序而需要CPU运行操作系统程序的时间

在对用户CPU时间进行计算时需要用到的指标:
1. `时钟周期`: 用于对控制信号定时的同步信号即为CPU的时钟信号,其宽度为一个时钟周期
2. `时钟频率`: CPU的主频 等于**1/CPU时钟周期** 与时钟周期互为倒数关系 单位为 Hz  1S / 时钟周期 = 时钟频率Hz 
3. `CPI(Clock cycle Per Instruction)`: 执行一条指令所需的时钟周期数

执行一条指令的耗时 = CPI x CPU时钟周期

CPU的执行时间 = 程序所含时钟周期数/时钟频率 = 程序所含的时钟周期数x时钟周期

如果已知程序总的指令条数和综合CPI,则可以使用如下公式计算程序的时钟周期数

程序总时钟周期数 = 程序所含指令条数 x CPI

`IPS(Instructions Per Second)`: 每秒执行多少条指令  IPS = 主频(时钟频率)/平均CPI

`MIPS`: 平均每秒执行多少百万条(10^6)指令

`FLOPS(Floating-point Operation Per Second)`: 每秒钟可以执行多少次浮点运算

指令平均时间(等效指令速度法或Gibson混合法): 等效质量的执行时间 T = W1 x T1 + W2 x T2 ... + Wn x Tn

其中:
Wi 为某类指令i在程序中所占比例
Ti 为执行时间
n  为指令种类数

1. 若指令的执行时间用时钟周期数衡量,T就是CPI
2. 指令平均执行时间的倒数就是MIPS值
3. `峰值MIPS`: 选取一组指令组合,使得得到的平均CPI最小,则其倒数就是峰值MIPS
4. 相对MIPS是根据某个公认的参考机型来定义相应MIPS值其值的含义是北侧机型相对于参考机型MIPS的多少倍
5. MIPS反应机器执行**定点指令**的速度,但是,用MIPS来对不同的机器进行性能比较有时是不准确或不客观的

`基准程序`: 专门用来进行性能评价的**一组程序**

SPEC测试程序集应用最广泛,也是最全面的性能评测基准程序集

## 总结

**难点**

1. 冯诺依曼计算机结构特点
2. 计算机的硬件组成
3. 计算机的工作过程
4. 计算机系统的层次结构
5. 计算机系统基本性能指标及性能评估

# 第二章 数据的表示和运算

## 数制和编码

`进位制`: 表示数时,仅用一位数码往往不够用,必须用进位计数的方法组成多位数码.多为数码每一位的构成以及从地位到高位的进位规则称为进位计数制简称进位制

`数值数据`: 用来表示数量的多少,可比较大小,分为整数和实数,整数又分为无符号和带符号两种

`非数值数据`: 没有大小之分,不表示数量的多少,主要包括字符数据和逻辑数据

`基数`: 进位制的基数,就是在该进制值中可能用到的符号个数

`位权(位的权数)`: 在某一进位制的数中,每一位的大小都对应着该位上的数码乘一个固定的数,这个固定的书就是这一位的权数.权数是一个幂

为什么使用二进制

1. 只有两种基本状态,容易使用物理器件表示
2. 编码,计数,运算都很简单,可使用开关电路实现
3. 两个符号刚好对应真,假,可以方便的实现逻辑判断,也能通过逻辑门电路实现算数运算

**十进制转换成R进制**
整数部分: 除基取余,上右下左
小数部分: 乘基取整,上左下右

## 整数的表示

`定点数`: 小数点的位置是固定的

`浮点数`: 小数点的位置根据需要可以左右移动

`定点整数`: 整数的小数点隐含在数的最右边,不需要表示小数点

`定点小数`: 整数的小数点隐含在最高数位的左边,不需要表示小数点

二进制整数分为无符号整数(unsigned integer)和带符号整数(signed integer)两种

`无符号整数`: 一个编码的所有二进制位都用来表示数值而没有符号位

`带符号整数`: 必须用一个二进制位来表示符号,也称为有符号整数

计算机系统中一般整数使用补码表示,优点为以下

1. 与原码和反码相比, 0 的补码表示形式唯一
2. 与原码和移码相比,补码运算系统是一种模运算系统,因而可用假发实现减法运算,且符号位可以和数值位一起参与运算
3. 与原码和反码相比,它比原码和反码多表示一个最小负数
4. 与反码相比,不需要通过循环进位来调整结果

### 原码/反码/补码

1. 符号位"0/1"对应"正/负",剩余的数值为表示真值的绝对值
2. 若机器字长n+1位,带符号整数的原码表示范围: -(2^n-1) <= x <= 2^n-1
3. 真值0有两种形式: +0 和 -0 [+0]原 = 0,0000000 [-0]原 = 1,0000000

缺点: **符号位不能参与运算**,需要设计复杂的硬件电路才能处理,成本很高.

用补码表示真值--**符号位可以参与运算**

对于正数 原码--反码--补码  都一样,不变
对于负数 原码<->[符号位不变,数值位取反]<->补码->[末位+1]->补码

例: 
+19  三码都为 00010011
-19  三码各为 10010011 11101100 11101101
-100 三码各为 11100100 10011011 10011100

> 三码最高位都为符号位信息

> 原码快速转换为补码: **从右往左找到第一个1,这个1左边的所有"数值位"按位取反**
> 反过来将补码转换为原码也一样

计算机硬件如何做**补码**的**加法**:从最低位开始,**按位相加(符号位参与运算)**,并往更高位**进位**

> 补码的数值位不能解读为**位权**

>将一个正数的补码快速转换为正数负值:**从右往左找到第一个1,这个1左边的所有位按位取反**

### 移码

补码的基础上将符号位取反 **注意: 移码只能用于表示整数**

移码的定义: 移码 = 真值 + **偏置值**

此处8位移码的偏置值 128D = 10000000B ,即 2^(n-1)

## 实数的表示

计算机中专门用浮点数来表示实数

浮点数的格式 

```
X = (-1)^s*M*R^E
```

S: 用来决定数X的符号,一般用 0 表示正 , 1 表示负
E: 阶码,为定点整数,常用补码或移码表示,阶码的位数决定数的范围
M: 尾数,为定点小数,常用补码或原码表示,位数的位数决定数的精度
R: 阶码的底,一般选择与尾数的基数相同,隐含表示

为了浮点数表示的唯一性和提高精确度,需要将非规格化的数据转换为规格化

`规格化`: 规定尾数的最高位必须是一个有效值.

### IEEE 754标准

提供了两种基本浮点数格式: 32位单精度和64位双精度

32位单精度: 1位符号位 8位阶码 23位尾数
64位双精度: 1位符号位 11位阶码 52位尾数

1. 基数隐含为 2
2. 尾数用**原码**表示,第一位总为1,因此可在尾数中缺省第一位的1,称为**隐藏位**,使得单精度格式的23位数实际上表示了24位有效数字,双精度格式的52位尾数实际上表示了53位有效数字
3. 阶用移码表示.
4. 阶码E的范围,对于单精度来说范围是 -126~127

> IEEE 754 规定隐藏位 "1" 的位置在小数点之前

形成 IEEE754 浮点数步骤

1. 规格化二进制数: 改变阶码,使小数点前面仅有第一位有效数字(1)
2. 计算阶码: 利用偏移值表示法,实际指数加上偏移值
3. 单精度的阶码加上偏移量 7FH (127)
4. 双精度浮点数的阶码加上偏移量 3FFH(1023)
5. 把数值的符号位,阶码和尾数组合在一起就得到了该数的浮点存储形式

例:

十进制 -9/16 转换为 IEEE754

1. 转换为二进制为 -0.1001B
2. 计算阶码 -1.001x2^-1 阶码为 -1
3. 计算阶码偏移量 -1 + 127 = 126 转换为8位二进制 01111110
4. 尾数补齐23位 001 0000 0000 0000 0000 0000
5. 符号位 负数为 1
6. 二进制表示为 1011 1111 0001 0000 0000 0000 0000 0000
7. 十六进制表示为 BF 10 00 00 H

机器数 C0 A0 00 00H 转换为 IEEE754单精度浮点数

1. 转换为二进制表示 1100 0000 1010 0000 0000 0000 0000 0000
2. 取出各位 1 10000001 010000000000000000000000
3. 计算阶码 10000001 转为十进制 129 - 127 = 2
4. 取出尾数转为十进制计算 0.01B = 0.25
5. 最终值为 -1 * 1.25 * 2 ^ 2 = -5.0

## 非数值数据的编码表示

逻辑值: 逻辑数据只能参加逻辑运算,并且是按位进行的

逻辑数据和数值数据都是一串 1 / 0 序列,在形式上没有任何差异,需要通过指令的操作码类型来识别他们.

西文: 由拉丁字母,数字,标点符号以及一些特殊符号所组成,统称为字符(character)
字符集: 所有字符的机核
码表: 字符集中每一个字符都有一个代码,构成了该字符集的代码表,简称码表

ASCII码(美国标准信息交换码): 每个字符由7个二进制位表示,其中B6-B4为高位,B3-B0是低位部分. 一个字符在计算机中实际上用8位表示,一般情况下最高位的B7为0,需要奇偶校验的时候可以用B7这位来当作奇偶校验位

汉字的输入码: 每个汉字用一个或者几个键来表示,这种对每个汉字用对应的按键进行的编码表示就是输入码,又称为外码
字符集与汉字内码: 在系统中进存储,查找,传送处理的一种编码方式

## 数据的宽度和存储

比特(bit): 进制数据的每一位(0/1)是组成二进制信息的最小单位,称为一个"比特",或"位元",简称"位".比特是计算机中处理,存储和传输信息的最小单位
字节(byte): 一个字节等于8个比特.在计算机内部二进制信息的计量单位是字节(byte)
字(word): 用来表示被处理信息的单位,用来度量各种数据类的宽度

存储容量的单位主要有

1KB = 1024字节
1MB = 2^20字节
1GB = 2^30字节
1TB = 2^40字节
1PB = 2^50字节
1EB = 2^60字节
1ZB = 2^70字节

大端(big endian)存储方式: 将数据的最高有效字节MSB存放在最小地址单元中,将最低有效字节LSB放在最大地址单元中
小端(little endian)存储方式: 将数据的最高有效字节MSB存放在最高地址单元中,将最低有效字节LSB放在最低地址单元中,intel 80x86

例题: 假定 int变量 i 的地址为 0800H 机器数为 01 23 45 67 H 则I所占的存储单元的地址为 0800H 0801H 0802H 0803H 写出大端和小端方式下的存储结果

大端:  0800H-01 0801H-23 0802H-45 0803H-67
小端:  0800H-67 0801H-45 0802H-23 0803H-01

## 数据校验码

**奇偶校验**

奇偶校验: 原理是在K 位的信息码中增加一位校验位代码,使 k+1 位码字中取值为 1 的个数总保持为偶数(偶校验)或奇数(奇校验)

如假设信息码为 0110101 要使用奇校验的情况就是在高位添加 0或者1 案例情况为 1 0110101

常用于内存

**海明校验**

原理是将数据按照某种规律分成若干组,对魅族进行相应的就检测,以提供多位校验信息,从而可对错误位置进行定位,并将其纠正

编码过程

1. 确定校验位的位数

假定被校验数据M的位数为n,校验位P为k位,则n和k必须满足下列关系: 2^k >= 1+n+k 即 2^k-1 >= n+k

2. 确定分组方式

数据为和校验位是一起被存储的,通过将他们中的各位按某种方式排列为一个(n+k)位的码字,将该码字中每一个出错位置与故障字的数值建立挂你先,这样就可通过故障字的值很快确定是该码字中的哪一位发生了错误,从而将其取反来进行纠正

3. 故障字的值

- 如果故障字各位全部是0,则表示没有发生错误
- 如果故障字中有且仅有一位为 1 则表示校验位中有一位出错,不需要纠正
- 如果故障字中多位为1,则表示有一个数据位出错,其在码字中的出错位置由故障字的数值来确定.纠正时只需要将出错位取反即可

单纠错码(SEC)
单纠错/双检错码(SEC-DED)

**循环冗余校验**

(Cyclic Redundancy Check) 简称CRC码,是一种具有较强检错,纠错能力的校验码,常用于外存储器的数据校验,在计算机通信中也被广泛采用

## 加法器和算术逻辑部件

基本的运算部件是 加法器,ALU,移位器,ALU的核心部件是加法器

全加器: 同时考虑两个加数和低位进位的一位加法器被称为全加器(Full Adder, 简称FA)

加法器(无符号数加法器): n位的加法器可由n个全加器实现,其中Ci是第I-1位向第i位的进位

4位补码计算

-7 + -6

转无符号原码：0111 0110
转无符号补码：1001 1010
无符号补码加：0011
补码值：-3
转无符号原码： 1101
真值：-13

## 定点数的移位运算

### 原码的算数移位

符号位保持不变,仅对数值位进行移位

右移: 高位补0,低位舍弃.若舍弃的位=0,则相当于/2;若舍弃的位!=0,则会**丢失精度**
左移: 低位补0,高位舍弃.若舍弃的位=0,则相当于*2;若舍弃的位!=0,则会**严重误差**

### 反码的算数移位

正数的反码和原码相同,因此对**正数反码的移位运算也和原码相同**

右移: 高位补0,低位舍弃
左移: 低位补0,高位舍弃

负数的反码数值位与原码相反,因此负数反码的移位运算规则如下

右移: 高位补1,低位舍弃
左移: 低位补1,高位舍弃

### 补码的算数移位

正数的补码和原码相同,因此对**正数补码的移位运算也和原码相同**

右移: 高位补0,低位舍弃
左移: 低位补0,高位舍弃

负数的补码=反码末位+1,导致反码最右边几个连续的1都因为进位而变为0,知道进位碰到第一个0为止

**规律--负数补码中,最右边的1及其右边同原码,最右边的1的左边同反码(取反)**

右移(同反码): 高位补1,低位舍弃
左移(同原码): 低位补0,高位舍弃

### 总结

正数的 三码 左右移 添补代码都为0

负数的 原码 左右移 添补代码都为0

负数的 反码 左右移 添补代码都为1

负数的 补码 左移低位补0 右移高位补1

左移相当于 *2 右移相当于 /2

由于位数有限,因此有时候无法用算数移位精确的等效乘除法

### 逻辑移位

逻辑右移: 高位补0
逻辑左移: 低位补0

与无符号数移位操作基本一样

### 循环移位

循环移位: 用移出的位补上空缺
带进位位的循环移位: 移出的位放到进位位,用原进位位补上空缺

## 定点乘法

### 原码一位乘法

每次参与运算的只有一个位

符号位单独处理: 符号位 = Xs⊕Ys

数值位**取绝对值**进行乘法计算

例. 设机器字长n+1 = 5位(含1符号位),[x]原 = 1.1101 [y]原 = 0.1011,采用原码一位乘法求 x*y

符号位为: 0⊕1 = 1 负数
数值位取绝对值进行二进制乘法: [|x|]原 = 0.1101,[|y|]原 = 0.1011

> 乘数的符号位不参与运算,可以省略
> **原码**一位乘**可以只用单符号位**
> 答题的结果最好写为源码机器数

假设机器字长 n+1 位,数值部分占 n 位
符号位通过**异或**决定;数值部分通过被乘数和乘数绝对值的`n轮`**加法,移位**完成根据当前乘数中参与运算的位确定(ACC)加什么.**若当前运算为=1,则(ACC+[|x|])原;若=0,则(ACC)+0 (根据MQ中的最低位决定)**
每轮加法后ACC,MQ的内容统一**逻辑右移**

### 补码一位乘法

和原码一位乘法相似

进行 n 轮加法,移位,**最后再多来一次加法**

每次加法可能 **+0, +[x]补, +[-x]补** (根据当前MQ中的 最低位, 辅助位 来确定加的是什么)

> 辅助位 - MQ中的"最低位" = 1  时, **(ACC)+[x]补**
> 辅助位 - MQ中的"最低位" = 0  时, **(ACC)+0**
> 辅助位 - MQ中的"最低位" = -1 时, **(ACC)+[-x]补**

每次移位是 "补码的**算数右移**"

**符号位参与运算**

在补码运算中,MQ 的右边被扩展出一个辅助位, 辅助位初始为 0 .每次右移会使 MQ 的最低位顶替原本的辅助位(事实上 MQ 共 n+2位(一位符号位,一位辅助位,n位数值位))

由于寄存器的位数一般是统一的,所以 ACC 和 X 也会使用 n+2 位,因此采用双符号位进行补码运算,补位在高位,也就是最左边.

双符号位,正是 00 ,负是 11

补码的**算数右移**: **符号位不动,数值位右移,正数右移补 0, 负数右移补 1(符号位是什么就补什么)**

## 定点除法

规律: 忽略小数点,每确定一位商,进行一次减法,得到4位余数,在余数末尾补0,再确定下一位商.确定五位商即可停止(在机器字长5位的情况下)

### 原码除法: 恢复余数法

符号位单独处理: 符号位 = **Xs⊕Ys**

数值位取绝对值进行除法运算

计算机默认在MQ低位上商 1 ,如果搞错了再改上商 0 ,并"恢复余数"

ACC , MQ 整体"逻辑左移".ACC高位丢弃,MQ低位补0

### 原码除法: 加减交替法(不恢复余数法)

恢复余数法: 当余数为负时商 0 ,并 +|除数|, 再左移, 再-|除数|
加减交替法: 当余数为负时商 0,并左移, 再 +|除数|

### 补码除法: 加减交替法

- 符号位参与运算
- 被除数/余数,除数都采用双符号位

被除数和除数同号,则被除数减去除数
异号则被除数加上除数

余数和除数**同号**,商 **1** , 余数**左移一位减去除数**;
余数和除数**异号**,商 **0** , 余数**左移一位加上除数**

重复n次

**末位商恒定置为1**

## 浮点数运算

步骤: 

1. 对阶
2. 尾数加减
3. 规格化
4. 舍入(保留限定位数的尾数)
5. 判断溢出

# 第三章 指令系统

指令(又称作机器指令): 是指示计算机执行某种操作的命令,是计算机运行的最小功能单位

一台计算机的所有指令的集合构成该计算机的**指令系统**,也称为**指令集**

> 一台计算机只能执行自己指令系统中的指令,不能执行其他系统的指令
> 
> Eg: X86 架构,ARM 架构

一条指令就是机器语言的一个语句,它是一组有意义的二进制代码

一条指令通常要包括操作码字段和地址码字段

操作码(OP)  地址码(A)
用户的操作  对谁进行操作

## 指令地址

一条指令可能包含 0个,1个,2个....地址码
根据地址码的数目不同,可以将指令分为 零地址指令,一地址指令....

### 零地址指令 (OP  )

- 不需要操作数,如空操作,停机,关中断等指令
- 堆栈计算机,两个操作数隐含存放在栈顶和次栈顶,计算结果压回栈顶

### 一地址指令 (OP A1)

- 只需要单操作数,如加1,减1,取反,求补等 
  - 指令含义: OP(A1) -> A1 CPU首先从A1所指向的主存单元中取出相应的数据,然后对这个数据执行OP(操作符)所指明的相对应的操作,得到运算结果后把结果写回A1所指的存储单元
  - 完成一条指令需要三次访存: 取指令 -> 读A1 -> 写A1
- 需要两个操作数,但其中一个操作数隐含在某个寄存器中(如隐含在ACC中)
  - 指令含义: (ACC)OP(A1) -> ACC
  - 完成一条指令需要两次访存: 取指令 -> 读A1

> A1指某个主存地址,(A1)表示A1所指向的地址中的内容

### 二地址指令 (OP A1(目的操作数) A2(源操作数))

- 常用于需要两个操作数的算数运算,逻辑运算相关指令
  - 指令含义: (A1)OP(A2) -> A1
  - 完成一条指令需要四次访存: 取指令 -> 读A1 -> 读A2 -> 写A1

### 三地址指令 (OP A1 A2 A3(结果))

- 常用于需要两个操作数的算数运算,逻辑运算相关指令
  - 指令含义: (A1)OP(A2) -> A3
  - 完成一条指令需要四次访存: 取指令 -> 读A1 -> 读A2 -> 写A3

### 四地址指令 (OP A1 A2 A3(结果) A4(下址))

- 指令含义: (A1)OP(A2) -> A3, A4=下一条将要执行指令的地址
  - 完成一条指令需要四次访存: 取指令 -> 读A1 -> 读A2 -> 写A3

正常情况下: 取指令之后PC+1,指向下一条指令
四地址指令: 执行指令后,将PC的值修改为A4所指的地址


n位地址码的直接寻址范围 = 2^n

若指令总长度固定不变,则地址码数量越多,寻址能力越差

`指令字长`: 一条指令的总长度(可能会变)
`机器字长`: CPU进行一次整数运算所能处理的二进制数据位数(通常与ALU直接相关)
`存储字长`: 一个存储单元中的二进制代码位数(通常和MDR位数相同)

## 数据寻址

`数据寻址`: 确定**本条指令**的**地址码指明的真实地址**
`形式地址`: 指令中的地址码字段称为形式地址

### 寻址方式

`直接寻址`: 指令字中的形式地址A就是操作数的真实地址EA 
- 优点: 简单指令执行阶段仅访问一次主存不需要专门计算操作数的地址
- 缺点: A的位数决定了该指令的操作数的寻址范围,操作数的地址不易修改

`间接寻址`: 指定地址字段给出的形式地址不是操作数的真正地址,二世操作数有效地址所在的存储单位的地址,也就是操作数地址的地址,即EA=(A)
- 优点: 可扩大寻址范围,便于编制程序
- 缺点: 指令在执行阶段要多次访存

`寄存器寻址`: 在指令字中直接给出操作数所在的寄存器编号,即EA=Ri,其操作数在由Ri所指的寄存器内
- 优点: 在执行阶段不访问主存,之访问寄存器,指令字短且执行速度快,支持向量/矩阵运算
- 缺点: 寄存器价格昂贵,寄存器个数有限

`寄存器间接寻址`: 寄存器Ri中给出的不是一个操作数,而是操作数所在主存单元的地址,即EA=(Ri)
- 优点: 比一般的间接寻址快

`立即寻址`: 形式地址A就是操作数本身,又称为立即数,一般采用补码形式 `#` 表示立即寻址特征
- 优点: 指令执行阶段不访问主存,指令执行时间最短
- 缺点: A的位数限制了立即数的范围,如A的位数为n,且立即数采用补码时,克表示的数据范围为 (-2^n-1)~(2^n-1)-1

**偏移寻址**

以某个地址作为起点,形式地址视为"偏移量"

`基址寻址`: 以程序的起始存放地址作为"起点"
`变址寻址`: 程序员自己决定从哪里作为"起点"
`相对寻址`: 以程序计数器PC所指地址作为"起点"

### 基址寻址

将CPU中的`基址寄存器(BR,base address register)`的内容加上指令格式中的形式地址A.而形成操作数的有效地址,即EA=(BR)+A

> 采用专用寄存器BR作为基址寄存器
> OS中的**重定位寄存器**就是**基址寄存器**
> 也有计算机内部没有专门的BR,而是使用通用寄存器作为基址寄存器,这时指令中需要给出寄存器的编号.根据通用寄存器的数量可以判断需要指令中需要几个bit来表示,如有8个通用寄存器,指令中需要3位来表示.

### 变址寻址

有效地址EA等于指令字中的形式地址A与`变址寄存器IX(index register)`的内容相加之和,即EA=(IX)+A,其中**IX可为变址寄存器(专用)**,也**可用通用寄存器作为变址寄存器**

变址寻址也可和间址寻址一起使用,根据执行顺序的不同分为以下两种

`前变址`: 先进行变址寻址然后再进行间址寻址 EA=((IX)+A)
`后变址`: 先进行间址寻址然后再进行变址寻址 EA=(IX)+(A)

### 相对寻址

把`程序计数器PC`的内容加上指令格式中的形式地址A而形成操作数的有效地址,即EA=(PC)+A,其中**A是相对于PC**所指地址的**位移量**,可正可负,**补码表示**

## 操作类型
指令系统的完备性要求在设计指令系统时必须考虑制冷系统应提供哪些操作类型,对大多数制冷系统考察后得知,操作类型按功能分为以下几种

### 算数和逻辑运算指令

这类指令有 加(ADD)减(SUB)比较(CMP)乘(MUL)除(DIV)与(AND)或(OR)取反(NOT)取负(NEG)异或(XOR)加1(INC)减1(DEC)等

### 移位指令

这类指令有算数移位,逻辑移位,循环移位,半字交换等


### 传送指令

传送指令通常有寄存器之间的传送(MOV),从内存单眼读取数据到CPU寄存器的(LOAD),从CPU寄存器写数据到内存单元(STORE)等

### 串指令

对于字符串进行操作的指令


### 顺序控制指令

用来控制程序执行的顺序

### CPU控制指令

这类指令有停机,开中断,关中断,系统模式切换以及进入特殊处理程序等指令.

### 输入输出指令

这类指令用于CPU与外部设备交换数据或传送控制命令以及状态信息.

## 操作码编码

`定长指令字结构`: 指令系统中所有指令的长度都相等
`变长指令字结构`: 指令系统中各种指令的长度不等

`定长操作码`: 指令系统中所有指令的操作码长度都相同
`可变长操作码`: 指令系统中各指令的操作码长度可变

定长指令字结构 + 可变长操作码 -> 扩展操作码指令格式

扩展操作码举例:

指令字长为 16 位,每个地址码4位,前4位为基本操作码字段OP,另有三个4位长的地址字段 A1,A2,A3

4位基本操作码若全用于三地址指令,则有16条
但至少须将1111 留作扩展操作码之用,即三地址指令为 15 条

1111 1111 留作扩展操作码之用,二地址指令为15条

1111 1111 1111 留作扩展操作码之用,一地址指令为15条

零地址指令为16条

还有其他扩展操作码设计方法

> 在设计扩展操作码指令格式时,必须注意以下两点
>
> 1. **不允许短码是长码的前缀**,即短操作码不能与长操作码的前面部分的代码相同
> 2. 各指令的操作码一定不能重复

通常情况下,对频率较高的指令,分配较短的操作码;对使用频率较低的指令,分配较长的操作码,从而尽可能减少指令译码和分析时间

### 指令系统设计风格

**按操作数位置指定风格来分**

1. 累加器(Accumulator)型指令系统: 这类指令系统中,总是把其中一操作数隐含在累加器中
2. 栈(stack)型系统: 栈是一种采后后进先出(LIFO)或先进后出(FILO)取方式的特定存储区
3. 通用寄存器(General Purpose Register)型指令系统: 特点是采用通寄存器而不是累加器存放运算过程中所用的临时数据
4. Load/Store型指令系统: 也是使用通用寄存器而不是累加器来存放运过程中所用的零食数据,但显著特点是,只有取(load)指令和存数(Store)令才可以访问存储器,运算类指令不能访存.

目前通用寄存器型指令系统占主导地位.

**按指令格式的复杂度来分**

- CISC(复杂指令集计算机Complex Instruction Set Computer)
  - 指令系统复杂: 指令多,寻址方式多,指令格式多
  - 指令周期长: 大多数指令需要多个时钟周期才能完成
  - 采用微程序控制: 由于有些指令非常复杂,以至于无法用硬连线控制器来实现,而微程序控制器用软件设计思想实现硬件,可以实现对复杂指令的控制
  - 难以进行编译优化: 由于编译器可选指令序列增多,使目标代码组合增加,从而增加了目标代码优化的难度
- RISC(精简指令集计算机Reduced Instruction Set Computer)
  - 指令条目少: 只包含使用频度高的指令
  - 指令格式规整: 寻址方式少,指令格式少,指令长度一致
  - 采用load/store型指令设计风格
  - 采用流水线方式执行指令: 规整的指令格式有利于采用流水线方式执行,除了Load/Store指令外,其他指令都只需一个或小于一个时钟周期就可以完成,指令周期短
  - 采用大量通用寄存器: 编译器可将变量分配到寄存器中,以减少访存次数
  - 采用硬连线控制器: 指令少而规整使得控制器的实现变得简答,可以不用或少用微程序控制
  - 采用优化的编译系统: 指令数少有利于编译器的优化

## MIPS指令集与其汇编语言

### 指令格式和寻址方式

MIPS 是典型的RISC结构,按字节编址,采用32位定长指令字,操作码字段也是固定长度,没有专门的寻址方式字段,由指令格式确定各操作数的寻址方式

MIPS指令采用三地址指令格式,只有三种类型

- R - 型指令:
格式: OP  rs  rt  rd  shamt  funct

这类指令的两个操作数和结果都存放在寄存器中,其操作码OP为"000000",造作类型由funct字段指定.

寻址方式只有一种: 寄存器直接寻址

- I - 型指令:
格式: OP  rs  rt  立即数

如果是双目运算类指令,则将rs内容和立即数分别作为第一和第二源操作数,结果送rt

寻址方式有四种: 寄存器直接寻址,立即数寻址,相对寻址,基址或变址寻址

- J - 型指令
格式: OP  直接地址

主要是无条件跳转指令,指令中给出的是 26 位直接地址,只要将PC的高四位拼上26位直接地址,最后添两个"0"就可以得到32位的跳转目标地址

寻址方式只有一种: 变通的直接寻址

### MIPS中数据的表示

1. MIPS指令中的操作数可以是立即数,或是通用寄存器的内容,也可以是存储单元的内容
2. MIPS处理器提供了32 个 32位通用寄存器,因此寄存器编号占5位. 例如R型指令格式中的rs,rt,rd和I型指令格式中的rs,rt都是指通用寄存器.

> 0号寄存器总是为0 , 31号寄存器用于存放过程调用的返回地址

寄存器的汇编表示以`$`符号开始,可以使用名称(如$a0),也可以使用编号(如$4)

3. MIPS还提供了32个32位的单精度浮点寄存器,用汇编符号$f0~$f31表示,他们可以配对成16个64位浮点寄存器,用来表示64位双精度浮点数
4. MIPS中提供了两个乘商寄存器Hi和Lo,他们无需程序员在指令中显式给出.用32位的Hi和Lo可实现一个64位寄存器.
5. MIPS中用程序计数器PC指出下一条指令的地址
6. MIPS的存储器按字节编址.对于存储器数据,其操作数地址为32位,通过一个32位寄存器的内容加16位偏移量得到.其中,32位寄存器就是I型指令中的rs,16位偏移量就是I型指令中的16位立即数,通常是一个带符号整数,因而,存储器操作数可访问的地址空间大小为 2^32字节
7. MIPS采用大端方式(Big Endian)存放数据,数据要求按字边界对齐.只能通过Load/Store指令访问存储器数据.
8. 对于立即操作数,指令中给出的位数为16位,指令执行时,需要将其进行符号扩展或0扩展,变成32位操作数后才能参加运算.

常用的5类指令: 算数运算,存储访问,逻辑运算,条件分支,无条件转移

1. 算数类指令包括算数运算和逻辑运算指令,它们可以是R-型格式指令,也可以是I-型格式指令 如:"sub $s1,$s2,$s3"的含义为"$s1 = $s2-$s3"

I-型格式运算类指令的汇编表示有一个特点,就是指令操作助记符总是以i结尾,而且第二个源操作数一定是一个立即数 如:"andi $s1,$s2,100"的含义为"$s1 = $s2&100"

2. 逻辑运算指令中还包括了逻辑左移sll和逻辑右移srl 如:"srl $s1,$s2,10"的功能为 "$s1 = $s2>>10" 含义为: 将寄存器$s2中的内容逻辑右移10位后送至寄存器$s1中,逻辑右移操作的实现方式为: 低位移出,高位补0

3. 存储访问类的指令有两种,一种是装入(Load)指令,另一种是存储(Store)指令 如:"lw $s1,100($s2)"的含义是,将存储单元中一个32位数据装入到通用寄存器$s1中,存储单元的首地址为$s2的内容加上100,因此,这里$s1,$s2和100分别是I-型指令中的rs,rt和16位立即数

4. 条件分支类指令包括条件设置指令(如 slt)和分支指令(如 beq,bne).条件设置指令slt用于比较两个寄存器内容的大小,或者将某个寄存器内容与一个立即数比较,前者为R-型格式指令,后者为I-型格式指令 如: R-型格式指令 "slt $s1,$s2,$s3"用于判断寄存器$s2和$s3内容的大小,若"小于"则$s1=1,否则$s1=0

分支指令beq,bne分别用于判断两个寄存器内容是否相等,不等,并更具判断结果确定是否转移到目标指令处执行,他们都是I-型格式指令,转移目标地址采用相对寻址方式,即转移目标地址=(PC)+偏移量,指令的16位立即数就是偏移量

5. 无条件跳转指令包括j,jal和jr等几条指令,j指令执行后,将直接跳转到转移目标地址;jal指令用于过程调用,在其执行过程中,将先把当前PC的内容(jal指令下条指令的地址)作为返回地址,保存到31号寄存器$ra中,然后再跳转到转移目标地址;jr指令用于过程返回,该指令将从31号寄存器$ra中取出返回地址,将其作为转移目标地址进行跳转

## 程序的机器级表示

1. 选择结构的机器代码表示
2. 循环结构的机器代码表示

# 第四章 中央处理器

## 程序的执行概述

`指令周期`: CPU取出并执行一条指令的时间

CPU执行一条指令的大致过程是: 取指令,指令译码,计算源操作数地址并取操作数,执行数据操作,计算目的操作数地址并存结果,计算下条指令地址

1. 取指令: 取指令的操作就是从PC所指出的存储单元中取出指令送到指令寄存器(IR)
2. 指令译码: CPU根据不同的指令**操作码**译出不同的控制信号
3. 计算源操作数地址并取操作数: 若源操作数是寄存器中的数据,则直接从寄存器取数后,转到下一步进行数据操作.若是存储器操作数,则需要访问存储器.在访存之前,需要根据**寻址方式**确定源操作数地址计算方式
4. 数据操作
5. 目的操作数地址计算并存结果
6. 指令地址计算并将其送PC

## CPU的基本功能和基本组成

CPU的基本职能: 就是周而复始的执行指令,机器指令执行过程中的全部操作都是由CPU中的控制器控制执行的

CPU最基本部件: 数据通路(datapath)和控制部件(control unit)

### CPU的基本组成

1. `程序计数器(PC)`: PC又称指令计数器或指令指针寄存器(IP),用来存放即将执行指令的地址
2. `指令寄存器(IR)`: IR用以存放现行指令
3. `指令译码器(ID)`: 指令译码器对指令寄存器中的操作码部分进行分析解释,产生相应的译码信号提供给操作控制信号形成部件,以产生控制信号
4. `启停控制逻辑`: 启停控制逻辑控制时序型号的发生与停止,并实现对机器的启动与停机

5. `时序信号产生部件`: 该部件以时钟脉冲为基础,产生不同指令对应的周期,节拍,工作脉冲等时序信号,实现机器指令执行过程的时序控制
6. `操作控制信号形成部件`: 该部件综合时序信号,指令译码信号和执行部件反馈的条件标志(如 CF,SF,OF等),形成不同指令的操作所需要的控制信号
7. `总线控制逻辑`: 实现对总线传输的控制,包括对数据和地址信息的缓冲与控制,其中包括用来缓存数据信息的存储器数据寄存器MDR和用来缓存地址信息的存储器地址寄存器MAR.CPU对于存储器的访问通过总线进行,CPU将存储访问命令(即读写控制信号)送到控制线,将要访问的存储单元地址送到地址线,并通过数据线取指令或者与存储器交换数据信息
8. `中断机构`: 实现对异常情况和外部中断请求的处理 

### 打断程序正常执行的事件

1. 对指令操作码进行译码时,发现是不存在的"非法操作码"
2. 在访问指令或数据时,发现尧都区的指令和数据不在主存中
3. 在ALU中运算的结果发生溢出,或者整数除法指令的除数为0
4. 在执行的过程中,CPU外部发生了采样计时是按到,网络数据包到达网络适配器,磁盘完成数据读写等外部事件,要求CPU中止当前程序的执行,专去执行专门的外部事件处理程序

**基本概念**

`异常控制(中断机制)`: CPU除了能正常执行指令以外,还必须具有程序正常执行被打断时的处理机制
`中断机构`: CPU中相应的异常和中断处理逻辑

**异常和中断**

所有这些打断程序正常执行的事件被分为两大类: 异常和中断

`异常`: 异常指是由CPU内部的异常引起的意外事件

  1. 硬故障中断是由于硬连线路出现异常而引起的,如电源掉电,校验线路错等
  2. 程序性异常是由CPU执行某条指令而引起的发生在CPU内部的异常事件.如除数为0,溢出,断点,单步跟踪寻址错,访问超市,非法操作码,栈溢出,缺页,地址越界(段错误)等

`中断`: 程序执行过程中,若外设完成任务或发生某些特殊事件,设备控制器会向CPU发中断请求,要求CPU对这些情况进行处理.这类事件与执行的指令无关,由CPU外部的I/O硬件发出,所以,称为I/O中断或外部中断,需要通过外部中断请求线向CPU请求

## 数据通路基本结构和定时

`数据通路`: 指令执行过程中数据所经过的路径,包括路径上的部件
`执行部件或功能部件`: 数据通路中专门进行数据运算的部件

数据通路由控制部件发出的控制信号进行控制

指令执行用到的元件有两类: 组合逻辑元件(也称操作元件)和时序逻辑元件(也称状态元件或存储元件)

连接这些元件的方式有两种: 总线方式和分散连接方式

数据通路就是由组合逻辑元件和时序逻辑元件通过总线或分散方式连接而成的进行数据存储,处理和传送的路径

`操作元件`: 组合逻辑元件的输出只取决于当前的输入.若输入一样,其输出也一样.组合电路的定时不受时钟信号的控制,所有输入信号到达后,经过一定的逻辑门延迟,输出端的值呗改变,并一直保持其值不变,直到输入信号改变

`状态元件`: 状态元件具有存储功能,输入状态在时钟控制下被写到电路中,并保持电路的输出值不变,直到下一个时钟到达.输入端状态由时钟决定何时被写入,输出端状态随时可以读出

**数据通路的时序控制**

早期计算机的定时方式

通常采用机器周期,节拍和脉冲三级时序对数据通路操作进行定时控制

现代计算机的定时方式

现代计算机中,整个数据通路中的定时信号就是时钟信号,一个时钟周期就是一个节拍,CPU的主频就是时钟信号的频率

## 数据通路基本工作原理

单总线数据通路结构中,几种基本操作过程

1. 在通用寄存器之间传送数据

 如 要将寄存器R0的内容传送到寄存器Y,则对应的控制信号取值为: R0out=1,Yin=1,其余寄存器的Rin和Rout信号都为0

 通常称取值为1的Rin和Rout信号为有效控制信号,在描述控制信号取值时,止泄出有效控制信号,如"R0out,Yin"

2. 完成算数逻辑运算

  ALU运算的其中一个操作数来自Y寄存器,另一个操作数被置于总线上,运算结果被临时存放在寄存器Z中

  例如: 完成指令"R[R3] <- R[R1] + R[R2]"的有效控制信号如下

  R1out,Yin
  R2out,add,(Zin)
  Zout,R3in

任何时刻只能将一个寄存器的内容送到内总线,任何异步结束时结果要送到某个寄存器的输入端(即保存到寄存器).因此,该操作需要三个时钟周期(节拍)

3. 从内存单元读取一个字
早期的计算机,CPU和主存之间采用"异步"方式进行通信

假定需要在某条指令中实现操作R[R2] <- M[R[R1]] 控制信号序列如下

  R1out,MARin
  read,WMFC
  MDRout,R2in

4. 把一个字写入内存单元

  M[R[R2]] <- R[R1]

  R1out,MDRin
  R2out,MAR
  write,WMFC

`单周期处理器`是指其所有指令的指令周期都为一个时钟周期,`单周期数据通路`既是单周期处理器中的数据通路.在单周期数据通路中,所有操作都需要在一个时钟周期内完成

## 流水线方式下指令的执行

一条指令的执行可被分为若干个阶段,每个阶段都在相应的功能部件中完成,如果将各阶段看成相应的流水段,则指令的执行过程就构成了一条指令流水线. 如,假定一条指令流水线由以下5个流水段组成

取指令(IF): 根据PC的值从存储器取出指令并更新PC
指令译码(ID): 产生指令执行所需的控制信号
取操作数(OF): 读取存储器操作数或寄存器操作数
执行(EX): 对操作数完成指定操作
写回(WB): 将操作结果写入存储或寄存器

MIPS指令系统中最复杂的指令需要5个阶段完成操作,因此,MIPS指令流水线数据通路通常用一个五段流水线实现,其执行过程和功能段划分如下

取指(Ifetch): 取指令并PC加4(MIPS每条指令占32位,4单元)
译码/取数(Reg/Dec): 读取寄存器内容并对指令译码
执行(Exec): 进行算数运算或逻辑运算(包括传送操作)
访存(Mem): 存储器读数或写数据
写回(Write): 选择存入寄存器的结果并将其在寄存器输入端稳定保持一段建立时间

适合流水线的指令集特征

1. 指令长度尽量一致
2. 指令格式尽量规整,尽量保证源寄存器的位置相同
3. 采用Load/stor型指令风格
4. 为了便于以流水线方式执行指令,数据和指令在存储器中要"对齐"存放

## 控制器设计基本原理

`控制器`: 是整个CPU的指挥控制中心,也称为控制部件,控制逻辑或控制单元,作用是对指令进行译码,将译码结果和状态/标志信号,时序信号等进行组合,产生指令执行过程中所需要的控制信号

`控制信号`: 用于控制数据通路中信息的流动

根据不同的控制描述方式,可以有硬连线控制器和微程序控制器两种实现方式

`硬连线控制器`: 基本实现思路是,将指令执行过程中每个时钟周期所包含的控制信号取值看成一个状态.每来一个时钟，控制信号就会有一组新的取值，也就是一个新的状态，这样，所有指令的执行过程就可以用一个有限状态转换图来描述。实现时使用一个组合逻辑电路(一般为PLA电路)来生成控制信号,用一个状态寄存器记录状态之间的转换.因此控制器实际上就是一个有限状态机

理论上来说,控制器设计的过程很简单,主要步骤如下

1. 根据每条指令的功能,确定每条指令的执行步骤,画出指令执行的流程图
2. 给出每条指令在每个步骤中各个控制信号的取值,并在表中列出
3. 根据指令和控制信号的关系,写出每个控制信号的逻辑表达式
4. 根据逻辑表达式,画出控制器的逻辑电路

优点: 控制器速度快,适合于实现简单,规整的指令系统,如MIPS指令系统
缺点: 多输入/多输出,复杂,巨大的网状逻辑,对于CISC这种复杂指令系统来说,由于其控制逻辑机器复杂,实现难度非常高,不易维护,扩充,修改

`多周期数据通路`: 对于总线结构数据通路,需要多个时钟周期才能完成一条指令的执行.通常把这种一个指令周期包含多个时钟周期的数据通路称为多周期数据通路.

`微程序控制器`: 基本实现思路是,仿照程序设计方法,将每条指令的执行过程用一个**微程序**来表示,将指令执行过程中每个时钟周期所包含的控制信号取值看成是由多个微命令组成的一条**微指令**

`微程序`: 每条指令的执行过程
`微指令`: 指令执行过程中每个时钟周期所包含的控制信号取值看成是由多个微命令组成的一条**微指令**
`微命令`: 每个控制信号对应一个微命令
`微地址`: 微指令所在的存储单元的地址

一个微程序由若干条微指令组成.每个控制信号对应一个微命令,控制信号取不同的值,就发出不同的微命令

`控制存储器(CS)`: 在CPU内部,用于存放微程序的**只读存储器**,简称控存

微程序的定序器的实现有计数器法和断定法(下地址字段法)两种

`计数器法`: 使用专门的微程序计数器μPC,将下条微指令地址隐含的存放在μPC中.顺序执行时,根据μPC + 1 -> μPC得到下条微指令的地址;执行转移时,在当前的微指令后添加一条"转移微指令",并在微指令中添加专门的"转移控制字段",将"转移微指令"或"转移控制字段"中的控制信息送到微指令地址发生器,与相应的指令操作码以及条件码等组合,生成转移微地址送μPC

`断定法`: 在微指令中增加一个下地址字段,在该字段中直接给出下条微指令地址,因此也称为下地址字段法

采用软件设计思想,不管指令多复杂,只要事先将其包含的操作所用的控制信号存储在控存中,就可以在指令执行时将控制信号取出,以控制指令执行.

CISC指令系统大多采用微程序控制器实现,不过,因为微程序控制器在每个时钟周期都要访问控制存储器,因此指令执行速度比较慢

## 指令流水线中的冒险处理

`流水线冒险(hazard)`: 指令序列在流水线中执行时,可能会遇到一些情况,使流水线无法正确,按时执行后续指令,从而引起流水线阻塞或停顿(stall)

类型:

`结构冒险`: 也称为硬件资源冲突,引起结构冒险的原因在于同一个部件同时被不同指令所用,也就是硬件资源竞争造成

解决策略有两种:

1. 规定一个部件每条指令只能使用一次,且只能在特定阶段使用
2. 通过设置多个独立的部件来避免资源冲突

`数据冒险`: 也称为数据相关,原因在于后面指令需要读取前面指令的运算结果时,前面指令的结果还没有写入寄存器中

解决策略有以下: 

1. 最简单是由编译器在数据相关的指令之间加若干nop指令(即空操作指令,除了修改PC外什么操作都不做)
2. 采用数据转发技术,数据通路中一旦产生运算结果或一旦存储器读出数据,就把他们通过一条旁路直接送到相关后续指令在执行阶段的ALU输入端
3. 对于无法通过转发来解决,可以在load指令后面加一条nop指令;也可以通过硬件阻塞的方式来延迟load指令随后的一条指令的执行,此时流水线阻塞一个时钟周期,程序执行时间延长一个时钟周期
4. 对于关于寄存器$8的数据相关问题,则可以通过对于通用寄存器的读写操作进行特殊处理

`控制冒险`: 正常情况下,指令在流水线中总是按顺序执行,当遇到改变指令执行顺序的情况时,流水线中指令的正常执行会被阻塞.这种由于发生了指令执行顺序改变而引起的流水线阻塞称为控制冒险

## 高级流水线基本原理

高级流水线技术充分利用指令级并行( Instruction-level parallelism ,简称为ILP )来提高流水线的性能。有两种增加指令级并行的策略。

`超流水线(super-pipelining)技术`: 通过增加流水线级数来时更多的指令同时在流水线中重叠执行

`多发射流水线技术`: 通过同时启动多条指令独立运行来提高指令并行性

实现多发射流水线必须完成以下两个任务

`指令打包`: 指令打包任务就是将能够并行处理的多条指令同时发送到发射槽中。

`冒险处理`: 指令打包依赖于推测结果，有可能结果时错误的，所以需要推测错误检测和回退机制

## 异常和中断

`异常`通常是由程序错误引起的，是计算机系统内部的问题
`中断`是由外部事件(I/O设备)引起的，是计算机系统与外部世界的交互

有时候为了强调异常是CPU内部执行指令时发生,而中断时CPU外部的I/O设备向CPU发出的请求,特称异常为`内部异常`,中断为`外部中断`

处理过程和实现机制基本相同

### 异常的分类

内部异常分为三类

`故障(fault)`,`陷阱(trap)`,`中止(abort)`

`故障`: 故障是在引起故障的指令被启动后但未执行结束时CPU检测到的一类与指令相关的意外事件,有些可以恢,有些不能

例子

1. 对于像溢出和非法操作码等这类故障,无法恢复
2. 对于除数为0的情况,根据是定点除法还是浮点除法指令有不同的处理方式
3. 对于页故障(page fault),对应的页故障处理程序会根据不同的情况进行不同的处理

`陷阱`: 也成为自陷或陷入,是预先安排的一种"异常事件",就像"陷阱"一样 ,可以用来进行系统调用

`终止`: 在指令过程中发生了非常严重的错误如控制器出现问题

### 中断的分类

`可屏蔽中断`: 指通过可屏蔽中断请求线INTR向CPU进行请求的中断,主要来自于I/O设备,CPU可以通过中断控制器中设置相应的屏蔽字来屏蔽或不屏蔽

`不可屏蔽中断`: 是非常紧急的硬件故障,通过不可屏蔽中断请求线请求

### 异常和中断的相应过程

`保护断点和程序状态`: 对于不同的异常事件,其返回地址(即断点)不同

`关中断`: 设置一种机制来精致在处理异常或中断时再响应新的异常或中断

`识别异常和中断事件并转相应处理程序执行`

# 存储器的层次结构

## 存储器概述

按存储元件分: 半导体存储器,磁表面存储器,光盘存储器

按存取方式分类: 随机存取存储器,顺序存取存储器,直接存取存储器

按信息的可更改性分类: 读写存储器,只读存储器

按断电后信息的可保存性分类: 非易失性存储器,易失性存储器

## 主存储器的组成和基本操作

`存储元(位元)`: 存储一位二进制代码
`存储单元(编址单位)`: 由多个存储元构成,可以存储多位二进制代码
`存储芯片`: 由多个存储单元组成的存储阵列构成
`存储器`: 由多个存储芯片构成
`存储容量`: 存储单元的位数与存储单元个数的乘积

写操作,读操作

`最大寻址范围`: 地址线的位数决定了主存地址空间的最大可寻址范围
`存储器容量`: 指存储器能存放的二进制位数或字数
`存取时间`: 一般用读出时间TA以及写入时间TW来描述
`存储周期`: 存储器进行一次读写操作所需要的全部时间
`存储器带宽`: 表示存储器被连续访问时,可以提供的数据传输速率,通常用每秒钟传送信息的位数来衡量
`存储器的价格`: 总价格C或每位价格c来表示
`存储器速度`: 可用存取时间,存储周期或带宽表示

**存储器的层次化结构**

寄存器
高速缓存
主存储器
辅助存储器
海量后备存储器

## 半导体随机存取存储器

### 基本存储元件

1. 六管静态MOS管存储元件 SRAM 静态RAM利用六管静态MOS管组成的双稳态电路来保存信息
2. 单管动态MOS管存储元件 DRAM 动态RAM利用MOS管的栅极电容Cs来保存信息。

静态存储元件和动态存储元件的比较

SRAM存储元件所用MOS管多,占硅片面积大,功耗大,集成度低,但无需刷新,也无需读后再生,读写速度快,适合作高速小容量的半导体存储器
DRAM存储元件所用MOS管少,占硅片面积小,功耗小,集成度高,但必须刷新,也需要读后再生,读写速度相对SRAM慢很多,适合做慢速大容量的主存

### 半导体RAM芯片

由 存储体,I/O读写电路,地址译码和控制电路等部分组成.

`存储体`: 存储体时存储单元的集合
`地址译码器`: 用来将地址转换为译码输出线上的高电平,以便驱动相应的读写电路 译码方式有单译码和双译码两种,容量较大的存储芯片一般采用双译码
`存储字`: 有些芯片的存储阵列采用三维结构,用多个位平面构成存储整列,不同位平面在相同行和列的交叉点上的多位构成一个存储字,被同时读出或写入
`驱动器`: 在双译码结构中,一条X方向的选择线要控制在其上的各个存储单元的字选择先,负载叫法,因此需要在地址译码器后加驱动电路
`I/O控制电路`: 用与控制被选中单元的读出或写入,具有放大信息的作用
`读/写控制信号`: 根据CPU给出的时读命令还是写命令,控制被选中存储单元进行读取或者写入

### SDRAM芯片技术

传统DRAM与CPU之间采用异步交换数据

SDRAM读写接受系统时钟控制,与CPU采用同步的方式交换数据

DDR SDRAM芯片技术采用两位预读取功能,能够在一个时钟内传送两次数据

DDR2 SDRAM能进行4位预取

DDR3 SDRAM能进行8位预取

## 存储芯片的扩展以及其与CPU的连接

### 内存条和内存插槽

CPU通过其芯片内的总线接口部件(总线控制逻辑)与系统总线相连,然后再通过总线之间的I/O桥接器,存储器总线连接到主存

### 存储芯片的扩展

扩展的步骤

- 确定需要的芯片数量
- 确定组织方式
- 画出地址分配图以及写出片选逻辑
- 画出存储器逻辑图或存储器与CPU的连接图

例题: 用8K x 1位的SRAM芯片构成8K x 8位存储器，地址线为A15(高)~A0(低)

1. 需要几片这种存储芯片
2. 存储器共需要几位地址?是哪几位地线
3. 加至各个芯片的地址线是哪几位

解:

1. 8K / 8K * 8bit / 1bit = 8(片)

```
8k   8bit
-- x ---- = 8
8k   1bit
```

2. 存储器是8kx8位, 8K = 2^3 * 2^10 = 2^13 ,存储器需要13位地址,即A12~A0
3. 存储芯片是8kx1位, 8K = 2^3 * 2^10 = 2^13 ,存储器需要13位地址,即A12~A0

例题: 用8K x 8位的SRAM芯片构成32K x 8位存储器，地址线为A15(高)~A0(低)

1. 需要几片这种存储芯片
2. 存储器共需要几位地址?是哪几位地线
3. 加至各个芯片的地址线是哪几位
4. 永远产生片选信号的地址线是哪几位(译码法)

解:

1. 32K / 8K * 8bit / 8bit = 4(片)
2. 存储器是32kx8位, 32K = 2^5 * 2^10 = 2^15 ,存储器需要15位地址,即A14~A0
3. 存储芯片是8kx8位, 8K = 2^3 * 2^10 = 2^13 ,存储器需要13位地址,即A12~A0
4. 15 - 13 = 2 是A13,A14  2-4

### 连续编址和交叉编址

`多模块存储器`: 通常把由多个独立并行工作的多个存储模块构成的存储器称之

根据不同的编址方式,多模块存储器分为连续编址和交叉编制两种

`连续编址方式`: 连续编址的多模块主存储器中，主存地址的高位表示模块号(或体号) ,低位表示模块内地址(或体内地址)因此,也称为按高位地址划分模块方式，地址在模块内连续。

`交叉编制方式`: 交叉编址存储器中，主存地址的低位表示模块号,高位表示模块内地址,因此，也称按低位地址划分模块方式。若有m个存储模块,则每个模块按"模m"交叉方式编址称为m体交叉编址方式。

## 半导体只读存储器和FLASH

根据只读存储器的工艺，可分为MROM,PROM,EPROM和EEPROM 等类型

1. 掩膜只读存储器( Mask ROM，MROM )中存储的信息由生产厂家在掩膜工艺过程中“写入”，用户不能修改。
2. 可编程只读存储器( Programmable ROM，PROM )芯片出厂时内容全部为0(半成品)，用户可用专门J的PROM写入器将信息写入,但写入不可逆，因此称为一次编程型只读存储器
3. 可擦除可编程只读存储器( Erasable Programmable ROMEPROM )允许用户通过某种编程器向ROM芯片中写入信息，并可擦除所有信息后重新写入。可反复擦除写入多次。
4. 电擦除电改写只读存储器( Electrically Erasable Programmable ROM , E2PROM )。这种存储器在读数据的方式上与EPROM完全一样，但它有一个明显优点，即可用电来擦除和重编程，因此，可以选择只删除个别字，而不像EPROM那样，每次都要抹除芯片上的全部信息,这给现场重编程带来极大的方便。

### 半导体FLASH存储器

Flash存储器也称为闪存，是高密度非易失性读写存储器，它兼有RAM和ROM的优点,而且功耗低、集成度高不需后备电源。这种器件沿用了EPROM的简单结构和浮栅/热电子注入的编程写入方式，又兼备E2PROM的可擦除特点，可在计算机内进行擦除和编程写入。因此又称为快擦型电可擦除重编程ROM。

闪存又三种基本操作: 编程(充电),擦除(放电),读取

## 高速缓冲存储器(cache)

主要解决问题

`地址映射`: 主存中的块放入Cache中的什么地方
`替换算法`: Cache放满的时候怎么办
`Cache一致性问题`: 写Cache时是否同时写入主存

`程序访问的局部性`: 在较短时间间隔内,程序产生的地址往往集中在存储空间的一个很小的范围,这种现象称之.时间局部性是指被访问的某个存储单元在一个较短的时间间隔内很可能又被访问

`空间局部性`: 是指被访问的某个单元存储单元的邻近单元在一个较短的时间间隔内很可能也被访问到

### Cache的基本工作原理

`cache`由快速的`SRAM`组成，直接制作在**CPU芯片内**也可在**CPU和主存之间**在CPU和主存之间设置cache，总是把主存中被频繁访问的活跃程序块和数据块复制到cache中。由于`程序访问的局部性`,大多数情况下CPU能直接从cache中**取得指令和数据**,而不必**访问主存**。

cache和主存控件都被划分为相等的区域.主存中的区域称为`块(block)` ,也称为主存块，它是cache和主存之间的**信息交换单位**; cache中存放一一个主存块的区域称为cache`行(line)`或`槽(slot)`

在系统启动或复位时，**每个cache行都为空**,其中的信息无效，只有**装入了主存块**后信息才有效。每个cache行需要一个`有效位( valid bit )`，可通过将有效位**清0来淘汰某cache行中的主存块**,称为`冲刷(flush)`， 装入一个新主存块时，再使有效位置1。

CPU在cache主存层次的平均访问时间为:

```
Ta = p*Tc+(1-p)x(Tm+Tc) = TC + (1-p)*Tm
```

其中**p是命中率**,**Tc是cache访问时间**,**Tm是把从主存读取一个主存块到cache的时间**,称为`缺失损失`

```
[计算题]假定处理器时钟周期为2ns，某程序有1000条指令
组成，每条指令执行一-次，其中的4条指令在取指令时,没有在
cache中找到，其余指令都能在cache中取到。在执行指令过程
中，该程序需要3000次主存数据访问，其中，6次没有在cache
中找到。试问:
( 1 )执行该程序得到的cache命中率是多少?
( 2 )若cache中存取一个信息的时间为1个时钟周期，缺失损
失为10个时钟周期,则CPU在cache-主存层次的平均访问时间
为多少?

[解析]
( 1 )执行该程序时的总访问次数为1000 +3000 =
4000，未命中次数为4+6 =10，故cache命中率为
(4000-10) / 4000 = 99.75%。
( 2 ) cache-主存层次的平均访问时间为1 + (1-99.75%)
x 10 =1.025个时钟周期，即1.025 x 2ns = 2.05ns
与cache的访问时间相近。
```

### cache行和主存块之间的映射方式

三种映射方式

`直接映射(direct map) `:每个主存块映射到cache的固定行中。
`全相联映射(full associate map)` :每个主存块映射到cache的任意行中。
`组相联映射(set associate map)` :每个主存块映射到cache的固定组的任意行中。


**直接映射计算**

cache 行号 = 主存块号 mod cache行数

主存地址结构如下

区号: 作为标记(表示为Tag),用于判断是否命中
块号: cache行号
块内地址: cache行内地址

块号加上块内地址 = cache地址

**全相联映射(full associate map)**
全相联映射的基本思想是一个主存块可装入cache任意一行中。全相联映射cache中,每行的标记用于指出该行取自主存的哪个块。

**组相联映射(set associate map)**\
组相联映射方式结合了直接映射和全相联映射的优点当cache的组数为1时， 变为全相联映射;当每组只有一个cache行时，则变为直接映射.

### 一致性问题

`全写法`:全写法(write through)的基本做法是:若写命中，则同时写cache和主存;若写不命中，则有以下两种处理方式。

1. 写分配法(write allocate)。先在主存块中更新相应存
储单元,然后分配一个cache行,将更新后的主存块装入到分配
的cache行中。
2. 非写分配法(not write allocate)。仅更新主存单元而
不装入主存块到cache中。

`回写法`: 回写法(write back)的基本做法是:若写命中，则信息只被
写入cache而不被写入主存;若写不命中,则在cache中分配一
行，将主存块调入该cache行中并更新相应单元的内容。因此
该方式下在写不命中时,通常采用写分配法进行写操作。


## 虚拟存储器

`虚拟存储器`: 借用外存为程序提供很大的虚拟存储空间

程序(program)是代码和数据的集合,程序的代码是一个机器指令序列,因而的概念.它可以作为目标模块存放在磁盘中

进程(process)就是程序的一次运行过程,程序是静态的,进程是动态的.

进程是操作系统对处理器中程序运行过程的一种抽象。进程有自己的生命周期，它由于任务的启动而创建随着任务的完成(或终止)而消亡,它所占用的资源也随着进程的终止而释放。一个可执行目标文件可以被多次加载执行,也就是说，一个程序可能对应多个不同的进程。

### 虚拟地址空间

虚拟存储器管理方式采用"请求分页"思想,每次访问仅将当前需要的页面调入主存，而将不活跃的页面放在磁盘上。当访问某个信息所在页不在主存时发生缺页,此时，从磁盘将缺失的页面调入主存。虚拟存储器机制为程序员提供了-一个极大的虚拟地址空间(逻辑地址空间)。

`末分配页`:没有和任何内容相关联的页。
`已分配页`:对于代码和数据等有内容的区域所关联的页面。

已分配页中又有两类:缓存页和未缓存页

`缓存页`:已调入主存而被缓存在DRAM中的页面，
`未缓存页`:未调入主存而存在磁盘上的页

任何时刻一个进程中的所有页面都被划分成三个不相交的页面
集合:未分配页集合、缓存页集合和未缓存页集合。

### 虚拟存储器的实现
借用外存为程序提供的很大的虚拟存储空间称为虚拟存储器。

虚拟存储器分成三种不同类型:分页式、分段式和段页式。

`分页式虚拟存储器`: 在分页式虚拟存储系统中，主存储器和虚拟地址空间都被划分成大小相等的页面,磁盘和主存之间按页面为单位交换信息。通常把虚拟地址空间中的页面称为虚拟页、逻辑页或虚页，主存空间中的页面被称为页框(页帧)、物理页或实页。有时虚拟页简称为VP ( virtual page )， 物理页简称为PF ( pageframe )或PP ( physical page )。

`页表(PageTable)`: 操作系统在主存中给每个进程都生成了一个页表每个虚拟页在页表中都有一个对应的页表项，其内容包括该虚拟页的存放位置、装入位( valid )、修改位( dirty)、使用位(替换控制位)、存取权限位和禁止缓存位等。

`地址转换(Address Translationg)`: 将虚拟地址转换为主存物理地址的转换工作由CPU中的存储器管理部件(Memory Management Unit ,简称 MMU)来完成。

`快表(TLB)`: 采用虚拟存储器机制后,使得访存次数增加了。为了减少访存次数,往往把页表中最活跃的几个页表项复制到高速缓存中，这种在高速缓存中的页表项组成的页表称为后备换缓冲器( Translation Lookaside Buffer )，通常简称为TLB或快表,相应地称主存中的页表为慢表。这样,在地址转换时，首先到快表中查页表项，如果命中，则无需访问主存中的页表。

`分段式虚拟存储器`: 根据程序的模块化性质，可按程序的逻辑结构划分成多个相对独立的部分,这些相对独立的部分被称为段( Segment )，每个段的描述信息通常有段名、段起点、段长等。

`段页式虚拟存储器`: 在段页式虚拟存储器中，程序按模块分段，段内再分页，用段表和页表(每段一个页表)进行两级定位管理。段表中每个表项对应一个段,每个段表项中包含一一个指向该段页表起始位置的指针，以及该段其他的控制和存储保护信息,由页表指明该段各页在主存中的位置以及是否装入、修改等状态信息。程序的调入调出按页进行，但它又可以按段实现共享和保护。因此，它兼有页式和段式的优点。它的缺点是在地址转换过程中需要多次查表，即先查段表，再查页表。

# 互联与输入输出组织

`输入输出系统`:通常把外部设备及其接口线路、I/O控制部件以及I/O软件统称之。

`输入输出组织的功能`:主要用于控制外设与内存、外设与CPU之间进行数据交换。

`输入输出设备(又称外围设备或外部设备，简称外设)`: 是计算机系统与人或它机之间进行信息交换的装置。


`输入设备的功能`是把数据、命令、字符、图形、图像、声音或电流、电压等信息，以计算机可以接收和识别的二进制代码形式输入到计算机中,供计算机进行处理。

`输出设备的功能`是把计算机处理的结果,变成人最终可以识别的数字、文字、图形、图像或声音等信息，然后播放、打印或显示输出。

键盘,鼠标,显示器

## 外部存储器

### 磁表面存储器

**性能指标**

记录密度: 道密度和位密度
存储容量
平均存取时间
数据传输速率

磁盘存储器有硬盘和软盘两种

### 冗余磁盘阵列

RAID技术有以下3个特性:

1. RAID由一组物理磁盘驱动器组成，在操作系统下它们被视为单个逻辑驱动器。
2. 数据分布在一-组物理磁盘上,可以连续分布也可以交叉分布,交叉分布时可以按小条带交叉分布,也可以按大数据块交叉分布。
3. 冗余磁盘用于存储校验信息,保证磁盘万-损坏时能恢复数据。

### U盘和固态硬盘

U盘也称为闪存盘,它采用flash存储器(即闪存)做成，属于非易失性半导体存储器。闪存沿用了EPROM的简单结构和浮栅/热电子注入的编程写入方式,又兼备E2PROM的可擦除特点，可在计算机内进行擦除和编程写入。因此又称为快擦型电可擦除重编程ROM。

移动硬盘是由微型硬盘配上特制的硬盘盒构成的一个大容量存储器。通过USB和IEEE1394接口和计算机连接,可以随时插拔。

固态硬盘( solid state disk , SSD )也被称为电子硬盘。它是一种使用NAND闪存组成的外部存储系统和U盘并没有本质差别,只是容量更大,存取性能更好。SSD中包含一个或多个闪存芯片和闪存翻译层( flash translation layer ) ,其中的闪存芯片相当于硬盘驱动器，闪存翻译层相当于磁盘控制器,用于把对逻辑块的请求转换成对底层闪存芯片的访问。

## 外设与CPU，主存的互连

### 总线概述

`互连结构`: 连接各部件的通路的集合。
`分散连接`: 各部件之间通过单独的连线互连。
`总线连接`: 将多个部件连接到一-组公共信息传输线上。

`总线`是计算机内数据传输的公共路径,用于实现连两个或两个以上部件之间的信息交换

`内部总线`指芯片内部连接各元件的总线

`系统总线`指连接CPU,存储器和各种I/O模块等主要部件的总线

系统总线通常由一组`控制线`、一组`数据线`和一组`地址线`构成。也有些总线**没有单独的地址线**，**地址信息**通过**数据线**来传送,这种情况为`数据线`和`地址线`**复用**,称为`信号线复用`。

`同步总线`采用公共的**时钟信号**进行定时,挂接在总线上的所有设备都从时钟线上获得定时信号。

`同步总线`通常采用**并行传输**方式。

现在越来越多的总线采用**异步串行**方式进行传输,每次在一根信号线上传送`数据位`。通过多个数据通道的组合，可以实现比传统并行总线高得多的数据传输带宽。

总线的性能指标通常包含以下几个方面。
1. 总线宽度

总线中数据线的条数称为总线宽度,它决定了同时传输的信息位数。

2. 总线的工作频率

总线的工作频率(也称为总线时钟频率)指用于总线上对各种操作进行定时的时钟信号的频率。通常以MHz或GHz为单位。

3. 总线的带宽
总线带宽指总线的`最大数据传输率`,即**总线在进行数据传输时单位时间内最多可传输的数据量**，不考虑其他如总线裁决、地址传送等所花的时间。

总线带宽的计算公式为:

B=WxF/N

其中 
`W`为总线宽度，通常以字节为单位; 
`F`为总线时钟频率; 
`N`为完成一次数据传送所用的时钟周期数。

4. 总线的寻址能力

总线的寻址能力主要指由地址线位数所确定的可寻址地址空间的大小。

5. 总线的定时方式

按照总线上信息传送的定时方式来分，有**同步通信**、**异步通信**和**半同步通信**三类。同步通信总线由时钟信号同步;异步通信总线指前一个信号的结束就是下一个信号的开始，信息的改变是顺序的;半同步通信总线则是同步和异步两类总线定时方式的结合。

6. 总线的突发传送

总线上数据传送分正常的**非突发方式**和**突发方式**两种。正常的传送方式在每个传送周期内都是先传送地址,再传送数据。

在突发( burst )传送方式下，总线能够进行连续的成块据传送,传送开始时,先给出数据块在存储器中的首地址,然后连续地传送数据块,后续数据的地址默认为前面数据的地址加1。

7. 总线的负载能力

总线的负载能力指总线上所能挂接的遵循总线电气规范的总线设备的数目。

### 基于总线的互联结构

`北桥`是一个`主存控制器集线器`( Memory Controller Hub,MCH )芯片，本质上是一个DMA ( Direct Memory Access )控制器，因此，可通过MCH芯片，直接访问主存和显卡中的显存。

`南桥`是一个`I/O控制器集线器`( I/O Controller Hub, ICH )芯片，其中可以集成USB控制器、磁盘控制器、以太网络控制器等各种外设控制器，也可以通过南桥芯片引出若干主板扩展槽，用以接插一些I/O控制卡,如声卡、视频卡(显卡)、网卡等。

`QPI总线`是一种基于包传输的串行高速点对点连接协议,采用差分信号与专门的时钟信号进行传输。

`存储器总线`早期的存储器总线由北桥芯片控制，处理器通过北桥芯片和主
存储器、图形卡(显卡)以及南桥芯片进行互连。

`I/O总线`用于为系统中的各种I/O设备提供输入/输出通路在物理.上通常是主板.上的一些I/O扩展槽。

## I/O接口

`I/O接口`:是介于外设和I/O总线之间,用来解决各个外设和主机之间的同步与协调、工作速度的匹配和数据格式的转换等问题的**逻辑部件**。外设的I/O接口又称`设备控制器`或`I/O控制器`或`I/O控制接口`，也称为`I/O模块`。

I/O接口是连接外设和主机的一一个"桥梁"， 因此它在外设侧和主机侧各有一个接口。**通常把它在主机侧的接口**称为`内部接口`, **在外设侧的接口**称为`外部接口`。

### I/O接口的功能

1. **数据缓冲**:在I/O接口中引入数据缓冲寄存器,以达到主机和外设工作速度的匹配。
2. **错误或状态检测**:在I/O接口中提供状态寄存器以保存各种状态信息,供CPU查用。
3. **控制和定时**:接受从系统总线来的控制命令和定时信号并提供控制和定时逻辑，以实现对数据通信过程的控制。控制命令指通过系统总线中的数据线传送到控制寄存器中的命令字I/O接口中的外设界面控制逻辑根据对命令字的译码结果来控制I/O接口与设备之间的数据通信过程。
4. **数据格式转换**:提供数据格式转换部件(如进行串一并转换的移位寄存器) , 使通过外部接口得到的数据转换为内部接口需要的格式,或在相反的方向进行数据格式转换。

### I/O端口及其编址

I/O端口实际上就是I/O接口中的寄存器。

给所有I/O接口中各个可访问的寄存器进行编址有两种方式:`独立编址`和`统一编址`。

`独立编址方式`
独立编址方式对所有的I/O端口单独进行编号,使它们成为一个独立的I/O地址空间。指令系统中需要有专门的I/O指令来访问I/O端口，I/O指令中地址码部分给出I/O端口号。

`统一编址方式`
统一编址方式下，I/O地址空间与主存地址空间统一编址，也即，将主存地址空间分出一部分地址给I/O端口进行编号,根据地址范围就可区分访问的是I/O端口还是主存单元,无需设置专|门的I/O指令,只要用一般的访存指令就可以存取I/O端口。也被称为"存储器映射方式"

## I/O控制方式

I/O数据传送主要有三种不同的控制方式:`程序直接控制`,`中断控制`和`DMA控制`

`程序直接控制`方式直接通过查询程序来控制主句和外设之间的数据交换,通常有以下两种类型

1. `无条件传送方式`也称为同步传送方式,主要用于对一些简单外设(如开关,继电器)在规定的时间用相应的I/O指令对接口中的寄存器进行信息的输入输出.其实质是通过程序来定时,以同步传送数据

2. `条件传送方式`也成为异步传送方式.通过在查询程序中安排相应的I/O指令,由这些指令直接从I/O接口中取得外设和接口的状态,如: "就绪 (Ready )"、"忙(Busy)"、"完成( Done )"等,根据这些状态来控制外设和主机的信息交换。也称为**程序查询方式**。

CPU和外设之间完成一次数据交换过程:

1. CPU执行相应的I/O指令向该接口送出"启动"命令,设备选择电路对CPU送出的地址进行译码,选中本I/O接口;
2. I/O接口通过连接电缆向外设发送"启动设备"命令;
3. 外设准备好一个数据,通过电缆向I/O接口中的数据缓冲寄存器输入数据;
4. 外设向I/O接口回送"设备工作结束"状态信号;
5. CPU通过执行指令不断读取I/O接口状态。查询到外设"准备就绪"
6. CPU通过执行I/O指令从数据缓冲寄存器读取数据。

根据查询被启动的方式的不同,条件式程序查询方式由两种:`定时查询`和`独占查询`

`定时查询`是指周期性地查询接口状态,每次查询总是一直等到条件满足,才进行一个数据的传送,传送完成后返回.定时查询的时间间隔与设备的数据传输率有关

`独占查询`方式下,CPU被独占用于某设备的I/O,完全控制I/O整个过程.也即CPU花费100%的时间在I/O操作上,此时,外设和CPU完全串行工作

### 程序中断I/O方式

`中断的概念`

中断控制I/O方式下,一旦外设完成任务,就会像CPU发中断请求.然后CPU暂停正在执行的其他进程,调出中断服务程序来执行,执行结束中断返回,回到被打断处继续执行.

现代计算机系统中都配有完善的异常和中断处理系统,它们有两个重要的不同点

1. "缺页"或"溢出"等异常事件是在执行特定指令过程中产生的,而中断相对于指令的执行则是异步的.也就是说中断不和任何指令相关联,也不会阻止恩赫指令的完成.因此,CPU只需要在一条新指令的指令周期开始之前,检测是否有外部发来的中断请求即可.

2. 异常的发生和异常事件的类型是由CPU自身发现和识别的,不必通过外部的某个信号通知CPU,而对于中断,CPU必须通过对外部中断请求线进行采样,并从总线上获取相应的中断源设备的标识信息,才能获知哪个设备发生了何种中断

中断系统的基本职能和结构

1. **及时记录各种中断请求信号**.通常用一个`中断请求寄存器`来保存
2. **自动响应中断请求**.CPU在每条指令执行完,下一条指令取出前,会自动检测中断请求引脚,发现有中断请求时,则根据情况决定是否响应和响应哪个中断请求
3. **自动判优**.在多个中断请求同时产生时,能够判断出中断的优先级

中断源的识别和判优方法可分为`软件查询`和`硬件判优`两大类

`软件查询`当CPU检测到中断请求时,通过中断响应,自动转到一个特定的中断查询程序,在中断查询程序中,按中断优先顺序依次查询哪个设备有中断请求,并转到第一个查询到有请求的中断服务程序去执行。对于这种用软件进行中断识别的方式,其中断接口的硬件结构很简单,只要一根中断请求线和一一个中断请求寄存器，而且，可通过改变软件中的查询顺序来改变中断响应优先级。

`硬件判优`硬件判优方式是一种向量中断方式,它不同于软件查询的中断处理技术。它根据中断控制器接口(如PIC )中的中断判优电路和编码器等,得到当前所有未被屏蔽的中断请求中具有最高响应优先权的中断源类型(即中断源标识信息)， 通过编码器输出的 i 最终被送到CPU中,CPU根据i的值找到对应中断服务程序的首地址PC和初始PSW。

4. **保护被中断程序的断点和现场**.因为中断响应后要转去执行中断服务程序，而执行完中断服务程序后,还要回到原来的程序继续运行。所以原程序被中止处的指令地址和原程序的程序状态和各寄存器的内容等必须被保存,以便能正确回到原被中止处继续执行。

5. **中断屏蔽**。通过中断屏蔽实现多重中断的嵌套执行，中断屏蔽功能通过一个中断屏蔽字寄存器来实现。中断系统允许CPU在执行某个中断服务程序时， 被新的中断请求打断,这就是中断嵌套技术。但是并不是所有的中断处理都可被新的中断打断,对于一些重要的紧急事件的处理，就要设置成不可被其他新中断事件打断，这就是中断屏蔽的概念。

中断系统中存在两种中断优先级。一种是中断响应优先级,另一种是中断处理优先级。

中断过程

中断过程包括两个阶段:`中断响应`和`中断处理`。中断响应阶段由硬件实现,而中断处理阶段则由CPU执行中断服务程序来完成,所以中断处理是由软件实现的。

`中断响应`是指主机发现中断请求,中止现行程序的执行到调出中断服务程序这一过程,因此,中断响应过程是处理器从一个进程切换到另一个进程的过程。

需要保存两类信息: `现场信息`和`断点信息`

`现场信息`是用户可见的通用寄存器的内容,这些通用寄存器中存放着程序执行到断点处的现行值;

`断点信息`是用指令无法直接读取的程序计数器PC和程序状态字寄存器PSWR等的内容。

中断响应的条件:

1. CPU处于"开中断"状态。
2. 至少要有一个末被屏蔽的中断请求。
3. 当前指令刚执行完。

在中断响应周期中,通过执行一条隐指令，完成以下几个操作。

1. 关中断:将中断允许标志置为禁止(即"关中断”)状态，这时将屏蔽掉所有可屏蔽中断请求。
2. 保护断点:将PC和PSW送入栈或特殊寄存器。
3. 识别中断源并转中断服务程序:通过某种方式，获得优先级最高的中断源所对应的中断服务程序的首地址初始PSW，并分别送PC和PSWR。

`中断处理`就是CPU执行一个中断服务程序的过程,完全由软件完成。中断服务程序包含三个阶段:`准备阶段`、`处理阶段`和`恢复阶段`。

### DMA方式

`DMA ( Direct Memory Access )`称为直接存储器存取该输入输出方式用专门的`DMA接口硬件`来控制外设与主存间的直接数据交换,数据不通过CPU。通常把专门用来控制总线进行DMA传送的接口硬件称为`DMA控制器`。在进行DMA传送时, CPU让出总线控制权,由DMA控制控制总线,通过"窃取" -一个主存周期完成和主存之间的一次数据交换,或独占若干个主存周期完成一批数据的交换。

三种DMA方式

1. CPU停止法。DMA传输时，由DMA控制器发一个停止信号给CPU ,使CPU脱离总线,停止访问主存，直到DMA传送一块数据结束。
2. 周期挪用法。DMA传输时, CPU让出一个总线事务周期由DMA控制器挪用一个主存周期来访问主存,传送完一个数据后立即释放总线。是一种单字传送方式。
3. 交替分时访问法。每个存储周期分成两个时间片,一个给CPU，一个给DMA，这样在每个存储周期内, CPU和DMA都可访问存储器。

DMA操作步骤

第一步:**DMA控制器的预置(初始化)**。

进程P1在进行数据传送之前, 先通过内核执行一段初始化程序,完成对DMA控制器中各参数寄存器的初始值的设定。主要操作包括以下三个方面。

1. 准备内存区。若是从外设输入数据,则进行内存缓冲区的申请，并对缓冲区进行初始化;若是输出数据到外设,则先在内存准备好数据。

2. 设置传送参数。执行I/O指令来测试外设状态,并对DMA控制器设置各种参数。例如，将内存首址传送到地址寄存器，将字计数值传送到字计数器,将读/写命令字传送到控制寄存器,将设备地址传送到设备地址寄存器等。

3. 发送"启动DMA传送"命令,然后调度CPU执行进程P2。

第二步: **DMA数据传送(DMA传送)**。

CPU对DMA传送参数进行预置并发送“启动DMA传送"命令后，就把数据传送的工作交给了DMA控制器。在整个DMA传送过程中,**不再需要CPU的参与**，**完全由DMA控制器实现数据的传送**。DMA控制器将内存地址送到总线，并在总线的读/写控制线上发出"读”命令或"写”命令,随后在数据线上给出数据。DMA控制器每完成一个数据的传送 ，就将字计数器减1并修改地址寄存器中的主存地址。当字计数器为0时,完成所有I/O操作。

第三步: **DMA结束处理(后处理)**

当字计数器为"0" , 则发出"DMA结束” 中断请求信号给CPU，转入中断服务程序,做一些数据校验等后处理工作。

## 重点难点

1、不同总线(同步总线、前端总线、QPI总线、存储器总线、PCI-Express总线 )带宽计算
2、I/O接口的功能和基本结构
3、中断响应和处理过程
4、DMA控制方式的基本原理。
