# 第一章
## 计算机系统的基本组成

**基本思想/结构特点**

1. 使用“存储程序”工作方式
2. 计算机由运算器,控制器,存储器,输入设备和输出设备5个基本部件组成
3. 存储器不仅能存放数据,而且也能存放指令,形式上数据和指令没什么区别,但计算机能区分它们; 控制器应能控制指令的自动执行; 运算器应能进行加减乘除四种基本算数运算,并且也能进行逻辑运算; 操作人员可以通过输入输出设备使用计算机
4. 计算机内部以二进制形式表达指令和数据; 每条指令由操作码和地址码两部分组成,操作码指出操作类型,地址码指出操作数的地址; 由一串指令组成程序

`硬件`: 计算机硬件主要包括中央处理器,存储器,I/O控制器,外部设备和总线等,是物理装置的总称

`软件`: 运行在硬件上的程序和数据以及相关的文档

`程序`: 是指挥计算机如何操作的一个**指令序列**,即程序由指令组成

`指令`: 是计算机硬件能够直接理解并执行的最**基本操作**

`数据`: 是指令操作的对象

`存储程序方式`: 将编制好的程序（由若干相应的指令构成）存入计算机的存储器,当计算机工作时,能自动的逐条取出指令并执行

`IAS计算机`: “存储程序” 计算机

**现代计算机的基本组成:**

硬件部分: 

- `中央处理器`（Central Processing Unit,CPU）有时简称为处理器,是整个计算机的核心部件,主要用于指令的执行。CPU主要包含两种基本部件**数据通路**和**控制器**。

  - `数据通路`主要包含**算数逻辑部件(ALU)**和**通用寄存器**等,其功能是用来执行算数和逻辑运算等操作。

  - `控制器`用来对指令进行**译码**,生成相应的控制信号,以控制数据通路进行正确的操作

- `存储器`分为**内存**和**外存**,
  
  - `内存`包括`主存储器`(main memory,简称主存)和`高速缓存`(cache)

  - `外存`包括`辅助存储器`和`海量后备存储器`.通常把系统运行时直接和主存交换信息的存储器称为辅助存储器,简称辅存,目前主要的辅助存储器是磁盘存储器和固态硬盘

- `外部设备`简称为外设,也成为`I/O设备`,I/O是输入输出(Input/Output)的缩写.外设通常由机械部分和电子部分组成,而且两部分通常是可以分开的,机械部分是外部设备本身,而电子部分则是控制外部设备的`I/O控制器或I/O适配器`,外设通过`I/O控制器或I/O适配器`连接到主机上,`I/O控制器或I/O适配器`统称为设备控制器

- `总线`(bus)是传输信息的介质,用于在部件之间传输信息,CPU,主存和I/O模块通过总线互联,在CPU和I/O模块中都内涵相应的存储部件,即**缓存器**

`ALU`是数据处理部件,用于执行数据的算数和逻辑运算,ALU处理的数据来自**寄存器堆**;

`磁盘和主存`是存储部件,分别用于存储长期保存信息和临时保存信息;

`各类总线以及总线接口部件`,I/O桥接器,I/O扩展槽,I/O控制器和显示适配器等都是互联部件,用于完成数据传送任务

所有这些部件的操作都通过`CPU`中的`控制器`对指令**译码**后送出的**控制信号**的控制来完成

## 计算机软件

- 软件
  - 系统软件
    - 操作系统
    - 语言处理程序(编译器)
    - 数据库管理系统(DBMS)
    - 实用程序(磁盘碎片整理等)
  - 应用软件: 专门为某些应用比所编写的各类程序

## 计算机系统的层次结构

```
    应用(问题)
    算法
    编程(语言)
    操作系统/虚拟机
    指令集体系结构(ISA)
    微体系结构
    功能部件/RTL
    电路
    器件
```

`汇编程序(assembler)`: 也称汇编器,用来将汇编语言源程序翻译成机器语言目标程序

`解释程序(interpreter)`: 也称解释器,用来将源程序中的语句按其执行顺序逐条翻译成机器指令并立即执行

`编译程序(compiler)`: 也称编译器,用来将高级语言源程序翻译成汇编语言或机器语言目标程序

`指令集体系结构(ISA)`: 机器语言程序所运行的计算机硬件和软件之间需要有一个"桥梁",这个在软件和硬件之间的界面就是指令集体系结构(Instruction Set Architecture,ISA),简称体系结构或系统结构(architecture),他是软件和硬件之间接口的一个完整定义.ISA定义了一台计算机可以执行的所有指令的集合,每条指令规定了计算机执行什么操作,所处理的操作数存放的地址控件以及操作数类型.

`微体系结构`: ISA是对指令系统的一种规定或结构规范,具体实现的组织(organization) 称为微体系结构(microarchitecture)简称微架构. 相同的ISA可能会具有不同的微体系结构

## 计算机系统的不同用户

`最终用户`: 使用应用程序完成特定任务的计算机用户

`系统管理员`: 指利用操作系统等软件提供的功能对系统进行配置,管理和维护,以建立高效合理的系统环境供计算机用户使用的操作人员

`应用程序员`: 指使用高级编程语言编制应用软件的程序员

`系统程序员`: 指设计和开发系统软件的程序员

## 程序开发和执行过程

假设有一个 hello.c 的文件

将 hello.c 进行预处理,编译,汇编和链接,最终生成可执行目标文件.例如在UNIX系统中可用GCC编译驱动程序进行处理

```
hello.c(C源程序)   预处理程(cpp)   hello.i(预处理后的源程序)   编译程序(ccl)   hello.s(汇编源程序)   汇编程序(as)   hello.o(可重定位目标程序)   链接程序(ld)   hello(可执行目标程序)
```

## 指令执行的过程

`通用寄存器组`: 用来存放操作数或操作数的地址

`标志寄存器`: 用来存放ALU运算得到的一些标志信息

`程序计数器(PC)`: 用来存放将要执行的下一条指令的地址

`指令寄存器(IR)`: 用来存放从主存中读出的指令

`主存地址`: 每个存储但愿的一个唯一编号

`存储地址寄存器(MAR,memory access register)`: 用来存放当前CPU所访问的内存单元的地址

`存储数据寄存器(MDR,memory data register)`: 用来存放CPU与主存储器交换的数据

可执行目标文件中包含机器代码段

机器代码段由一条一条指令构成

程序被启动后,CPU通过逐条执行程序中的指令来实现程序的功能

**执行过程**

1. 根据PC取指令到IR
2. 指令译码并送出控制信号
3. 取操作数
4. 执行指令
5. 写回结果

PC更新: 为了能自动执行程序中的指令 CPU必须能够自动得到下一条指令的地址并送PC,所以取出指令送到IR稳定后,PC自动更新

定长指令字系统: 每条指令的长度都一样
          PC = PC + 指令长度(相同值)

变长指令字系统: 每条指令的长度不一样
          PC = PC + 指令长度(不同值)

`指令周期`: 从一条指令的启动到下一条指令的启动之间的间隔时间 

`机器周期`: 是指令执行中每一步操作所需的时间.一般以CPU中完成一个原运算操作所需的时间作为机器周期的基本时间,机器周期也叫CPU周期

`时钟周期`: 指计算机的主频周期,也成为T周期或T状态

## 计算机系统性能评价

`吞吐率(带宽)`: 表示在单位时间内所完成的工作量
`响应时间(执行时间或等待时间)`: 是指从作业提交开始到作业完成所需要的时间

`CPU时间`: 指CPU用于程序执行的时间,包括用户CPU时间和系统CPU时间
  - 用户CPU时间: 指真正用于运行用户程序代码的时间
  - 系统CPU时间: 指为了执行用户程序而需要CPU运行操作系统程序的时间

在对用户CPU时间进行计算时需要用到的指标:
1. `时钟周期`: 用于对控制信号定时的同步信号即为CPU的时钟信号,其宽度为一个时钟周期
2. `时钟频率`: CPU的主频 等于**1/CPU时钟周期** 与时钟周期互为倒数关系 单位为 Hz  1S / 时钟周期 = 时钟频率Hz 
3. `CPI(Clock cycle Per Instruction)`: 执行一条指令所需的时钟周期数

执行一条指令的耗时 = CPI x CPU时钟周期

CPU的执行时间 = 程序所含时钟周期数/时钟频率 = 程序所含的时钟周期数x时钟周期

如果已知程序总的指令条数和综合CPI,则可以使用如下公式计算程序的时钟周期数

程序总时钟周期数 = 程序所含指令条数 x CPI

`IPS(Instructions Per Second)`: 每秒执行多少条指令  IPS = 主频(时钟频率)/平均CPI

`MIPS`: 平均每秒执行多少百万条(10^6)指令

`FLOPS(Floating-point Operation Per Second)`: 每秒钟可以执行多少次浮点运算

指令平均时间(等效指令速度法或Gibson混合法): 等效质量的执行时间 T = W1 x T1 + W2 x T2 ... + Wn x Tn

其中:
Wi 为某类指令i在程序中所占比例
Ti 为执行时间
n  为指令种类数

1. 若指令的执行时间用时钟周期数衡量,T就是CPI
2. 指令平均执行时间的倒数就是MIPS值
3. `峰值MIPS`: 选取一组指令组合,使得得到的平均CPI最小,则其倒数就是峰值MIPS
4. 相对MIPS是根据某个公认的参考机型来定义相应MIPS值其值的含义是北侧机型相对于参考机型MIPS的多少倍
5. MIPS反应机器执行**定点指令**的速度,但是,用MIPS来对不同的机器进行性能比较有时是不准确或不客观的

`基准程序`: 专门用来进行性能评价的**一组程序**

SPEC测试程序集应用最广泛,也是最全面的性能评测基准程序集

## 总结

**难点**

1. 冯诺依曼计算机结构特点
2. 计算机的硬件组成
3. 计算机的工作过程
4. 计算机系统的层次结构
5. 计算机系统基本性能指标及性能评估

# 第二章 数据的表示和运算

## 数制和编码

`进位制`: 表示数时,仅用一位数码往往不够用,必须用进位计数的方法组成多位数码.多为数码每一位的构成以及从地位到高位的进位规则称为进位计数制简称进位制

`数值数据`: 用来表示数量的多少,可比较大小,分为整数和实数,整数又分为无符号和带符号两种

`非数值数据`: 没有大小之分,不表示数量的多少,主要包括字符数据和逻辑数据

`基数`: 进位制的基数,就是在该进制值中可能用到的符号个数

`位权(位的权数)`: 在某一进位制的数中,每一位的大小都对应着该位上的数码乘一个固定的数,这个固定的书就是这一位的权数.权数是一个幂

为什么使用二进制

1. 只有两种基本状态,容易使用物理器件表示
2. 编码,计数,运算都很简单,可使用开关电路实现
3. 两个符号刚好对应真,假,可以方便的实现逻辑判断,也能通过逻辑门电路实现算数运算

**十进制转换成R进制**
整数部分: 除基取余,上右下左
小数部分: 乘基取整,上左下右

## 整数的表示

`定点数`: 小数点的位置是固定的

`浮点数`: 小数点的位置根据需要可以左右移动

`定点整数`: 整数的小数点隐含在数的最右边,不需要表示小数点

`定点小数`: 整数的小数点隐含在最高数位的左边,不需要表示小数点

二进制整数分为无符号整数(unsigned integer)和带符号整数(signed integer)两种

`无符号整数`: 一个编码的所有二进制位都用来表示数值而没有符号位

`带符号整数`: 必须用一个二进制位来表示符号,也称为有符号整数

计算机系统中一般整数使用补码表示,优点为以下

1. 与原码和反码相比, 0 的补码表示形式唯一
2. 与原码和移码相比,补码运算系统是一种模运算系统,因而可用假发实现减法运算,且符号位可以和数值位一起参与运算
3. 与原码和反码相比,它比原码和反码多表示一个最小负数
4. 与反码相比,不需要通过循环进位来调整结果

### 原码/反码/补码

1. 符号位"0/1"对应"正/负",剩余的数值为表示真值的绝对值
2. 若机器字长n+1位,带符号整数的原码表示范围: -(2^n-1) <= x <= 2^n-1
3. 真值0有两种形式: +0 和 -0 [+0]原 = 0,0000000 [-0]原 = 1,0000000

缺点: **符号位不能参与运算**,需要设计复杂的硬件电路才能处理,成本很高.

用补码表示真值--**符号位可以参与运算**

对于正数 原码--反码--补码  都一样,不变
对于负数 原码<->[符号位不变,数值位取反]<->补码->[末位+1]->补码

例: 
+19  三码都为 00010011
-19  三码各为 10010011 11101100 11101101
-100 三码各为 11100100 10011011 10011100

> 三码最高位都为符号位信息

> 原码快速转换为补码: **从右往左找到第一个1,这个1左边的所有"数值位"按位取反**
> 反过来将补码转换为原码也一样

计算机硬件如何做**补码**的**加法**:从最低位开始,**按位相加(符号位参与运算)**,并往更高位**进位**

> 补码的数值位不能解读为**位权**

>将一个正数的补码快速转换为正数负值:**从右往左找到第一个1,这个1左边的所有位按位取反**

### 移码

补码的基础上将符号位取反 **注意: 移码只能用于表示整数**

移码的定义: 移码 = 真值 + **偏置值**

此处8位移码的偏置值 128D = 10000000B ,即 2^(n-1)

## 实数的表示

计算机中专门用浮点数来表示实数

浮点数的格式 

```
X = (-1)^s*M*R^E
```

S: 用来决定数X的符号,一般用 0 表示正 , 1 表示负
E: 阶码,为定点整数,常用补码或移码表示,阶码的位数决定数的范围
M: 尾数,为定点小数,常用补码或原码表示,位数的位数决定数的精度
R: 阶码的底,一般选择与尾数的基数相同,隐含表示

为了浮点数表示的唯一性和提高精确度,需要将非规格化的数据转换为规格化

`规格化`: 规定尾数的最高位必须是一个有效值.

### IEEE 754标准

提供了两种基本浮点数格式: 32位单精度和64位双精度

32位单精度: 1位符号位 8位阶码 23位尾数
64位双精度: 1位符号位 11位阶码 52位尾数

1. 基数隐含为 2
2. 尾数用**原码**表示,第一位总为1,因此可在尾数中缺省第一位的1,称为**隐藏位**,使得单精度格式的23位数实际上表示了24位有效数字,双精度格式的52位尾数实际上表示了53位有效数字
3. 阶用移码表示.
4. 阶码E的范围,对于单精度来说范围是 -126~127

> IEEE 754 规定隐藏位 "1" 的位置在小数点之前

形成 IEEE754 浮点数步骤

1. 规格化二进制数: 改变阶码,使小数点前面仅有第一位有效数字(1)
2. 计算阶码: 利用偏移值表示法,实际指数加上偏移值
3. 单精度的阶码加上偏移量 7FH (127)
4. 双精度浮点数的阶码加上偏移量 3FFH(1023)
5. 把数值的符号位,阶码和尾数组合在一起就得到了该数的浮点存储形式

例:

十进制 -9/16 转换为 IEEE754

1. 转换为二进制为 -0.1001B
2. 计算阶码 -1.001x2^-1 阶码为 -1
3. 计算阶码偏移量 -1 + 127 = 126 转换为8位二进制 01111110
4. 尾数补齐23位 001 0000 0000 0000 0000 0000
5. 符号位 负数为 1
6. 二进制表示为 1011 1111 0001 0000 0000 0000 0000 0000
7. 十六进制表示为 BF 10 00 00 H

机器数 C0 A0 00 00H 转换为 IEEE754单精度浮点数

1. 转换为二进制表示 1100 0000 1010 0000 0000 0000 0000 0000
2. 取出各位 1 10000001 010000000000000000000000
3. 计算阶码 10000001 转为十进制 129 - 127 = 2
4. 取出尾数转为十进制计算 0.01B = 0.25
5. 最终值为 -1 * 1.25 * 2 ^ 2 = -5.0

## 非数值数据的编码表示

逻辑值: 逻辑数据只能参加逻辑运算,并且是按位进行的

逻辑数据和数值数据都是一串 1 / 0 序列,在形式上没有任何差异,需要通过指令的操作码类型来识别他们.

西文: 由拉丁字母,数字,标点符号以及一些特殊符号所组成,统称为字符(character)
字符集: 所有字符的机核
码表: 字符集中每一个字符都有一个代码,构成了该字符集的代码表,简称码表

ASCII码(美国标准信息交换码): 每个字符由7个二进制位表示,其中B6-B4为高位,B3-B0是低位部分. 一个字符在计算机中实际上用8位表示,一般情况下最高位的B7为0,需要奇偶校验的时候可以用B7这位来当作奇偶校验位

汉字的输入码: 每个汉字用一个或者几个键来表示,这种对每个汉字用对应的按键进行的编码表示就是输入码,又称为外码
字符集与汉字内码: 在系统中进存储,查找,传送处理的一种编码方式

## 数据的宽度和存储

比特(bit): 进制数据的每一位(0/1)是组成二进制信息的最小单位,称为一个"比特",或"位元",简称"位".比特是计算机中处理,存储和传输信息的最小单位
字节(byte): 一个字节等于8个比特.在计算机内部二进制信息的计量单位是字节(byte)
字(word): 用来表示被处理信息的单位,用来度量各种数据类的宽度

存储容量的单位主要有

1KB = 1024字节
1MB = 2^20字节
1GB = 2^30字节
1TB = 2^40字节
1PB = 2^50字节
1EB = 2^60字节
1ZB = 2^70字节

大端(big endian)存储方式: 将数据的最高有效字节MSB存放在最小地址单元中,将最低有效字节LSB放在最大地址单元中
小端(little endian)存储方式: 将数据的最高有效字节MSB存放在最高地址单元中,将最低有效字节LSB放在最低地址单元中,intel 80x86

例题: 假定 int变量 i 的地址为 0800H 机器数为 01 23 45 67 H 则I所占的存储单元的地址为 0800H 0801H 0802H 0803H 写出大端和小端方式下的存储结果

大端:  0800H-01 0801H-23 0802H-45 0803H-67
小端:  0800H-67 0801H-45 0802H-23 0803H-01

## 数据校验码

**奇偶校验**

奇偶校验: 原理是在K 位的信息码中增加一位校验位代码,使 k+1 位码字中取值为 1 的个数总保持为偶数(偶校验)或奇数(奇校验)

如假设信息码为 0110101 要使用奇校验的情况就是在高位添加 0或者1 案例情况为 1 0110101

常用于内存

**海明校验**

原理是将数据按照某种规律分成若干组,对魅族进行相应的就检测,以提供多位校验信息,从而可对错误位置进行定位,并将其纠正

编码过程

1. 确定校验位的位数

假定被校验数据M的位数为n,校验位P为k位,则n和k必须满足下列关系: 2^k >= 1+n+k 即 2^k-1 >= n+k

2. 确定分组方式

数据为和校验位是一起被存储的,通过将他们中的各位按某种方式排列为一个(n+k)位的码字,将该码字中每一个出错位置与故障字的数值建立挂你先,这样就可通过故障字的值很快确定是该码字中的哪一位发生了错误,从而将其取反来进行纠正

3. 故障字的值

- 如果故障字各位全部是0,则表示没有发生错误
- 如果故障字中有且仅有一位为 1 则表示校验位中有一位出错,不需要纠正
- 如果故障字中多位为1,则表示有一个数据位出错,其在码字中的出错位置由故障字的数值来确定.纠正时只需要将出错位取反即可

单纠错码(SEC)
单纠错/双检错码(SEC-DED)

**循环冗余校验**

(Cyclic Redundancy Check) 简称CRC码,是一种具有较强检错,纠错能力的校验码,常用于外存储器的数据校验,在计算机通信中也被广泛采用

## 加法器和算术逻辑部件

基本的运算部件是 加法器,ALU,移位器,ALU的核心部件是加法器

全加器: 同时考虑两个加数和低位进位的一位加法器被称为全加器(Full Adder, 简称FA)

加法器(无符号数加法器): n位的加法器可由n个全加器实现,其中Ci是第I-1位向第i位的进位

4位补码计算

-7 + -6

转无符号原码：0111 0110
转无符号补码：1001 1010
无符号补码加：0011
补码值：-3
转无符号原码： 1101
真值：-13

## 定点数的移位运算

### 原码的算数移位

符号位保持不变,仅对数值位进行移位

右移: 高位补0,低位舍弃.若舍弃的位=0,则相当于/2;若舍弃的位!=0,则会**丢失精度**
左移: 低位补0,高位舍弃.若舍弃的位=0,则相当于*2;若舍弃的位!=0,则会**严重误差**

### 反码的算数移位

正数的反码和原码相同,因此对**正数反码的移位运算也和原码相同**

右移: 高位补0,低位舍弃
左移: 低位补0,高位舍弃

负数的反码数值位与原码相反,因此负数反码的移位运算规则如下

右移: 高位补1,低位舍弃
左移: 低位补1,高位舍弃

### 补码的算数移位

正数的补码和原码相同,因此对**正数补码的移位运算也和原码相同**

右移: 高位补0,低位舍弃
左移: 低位补0,高位舍弃

负数的补码=反码末位+1,导致反码最右边几个连续的1都因为进位而变为0,知道进位碰到第一个0为止

**规律--负数补码中,最右边的1及其右边同原码,最右边的1的左边同反码(取反)**

右移(同反码): 高位补1,低位舍弃
左移(同原码): 低位补0,高位舍弃

### 总结

正数的 三码 左右移 添补代码都为0

负数的 原码 左右移 添补代码都为0

负数的 反码 左右移 添补代码都为1

负数的 补码 左移低位补0 右移高位补1

左移相当于 *2 右移相当于 /2

由于位数有限,因此有时候无法用算数移位精确的等效乘除法

### 逻辑移位

逻辑右移: 高位补0
逻辑左移: 低位补0

与无符号数移位操作基本一样

### 循环移位

循环移位: 用移出的位补上空缺
带进位位的循环移位: 移出的位放到进位位,用原进位位补上空缺

## 定点乘法

### 原码一位乘法

每次参与运算的只有一个位

符号位单独处理: 符号位 = Xs⊕Ys

数值位**取绝对值**进行乘法计算

例. 设机器字长n+1 = 5位(含1符号位),[x]原 = 1.1101 [y]原 = 0.1011,采用原码一位乘法求 x*y

符号位为: 0⊕1 = 1 负数
数值位取绝对值进行二进制乘法: [|x|]原 = 0.1101,[|y|]原 = 0.1011

> 乘数的符号位不参与运算,可以省略
> **原码**一位乘**可以只用单符号位**
> 答题的结果最好写为源码机器数

假设机器字长 n+1 位,数值部分占 n 位
符号位通过**异或**决定;数值部分通过被乘数和乘数绝对值的`n轮`**加法,移位**完成根据当前乘数中参与运算的位确定(ACC)加什么.**若当前运算为=1,则(ACC+[|x|])原;若=0,则(ACC)+0 (根据MQ中的最低位决定)**
每轮加法后ACC,MQ的内容统一**逻辑右移**

### 补码一位乘法

和原码一位乘法相似

进行 n 轮加法,移位,**最后再多来一次加法**

每次加法可能 **+0, +[x]补, +[-x]补** (根据当前MQ中的 最低位, 辅助位 来确定加的是什么)

> 辅助位 - MQ中的"最低位" = 1  时, **(ACC)+[x]补**
> 辅助位 - MQ中的"最低位" = 0  时, **(ACC)+0**
> 辅助位 - MQ中的"最低位" = -1 时, **(ACC)+[-x]补**

每次移位是 "补码的**算数右移**"

**符号位参与运算**

在补码运算中,MQ 的右边被扩展出一个辅助位, 辅助位初始为 0 .每次右移会使 MQ 的最低位顶替原本的辅助位(事实上 MQ 共 n+2位(一位符号位,一位辅助位,n位数值位))

由于寄存器的位数一般是统一的,所以 ACC 和 X 也会使用 n+2 位,因此采用双符号位进行补码运算,补位在高位,也就是最左边.

双符号位,正是 00 ,负是 11

补码的**算数右移**: **符号位不动,数值位右移,正数右移补 0, 负数右移补 1(符号位是什么就补什么)**

## 定点除法

规律: 忽略小数点,每确定一位商,进行一次减法,得到4位余数,在余数末尾补0,再确定下一位商.确定五位商即可停止(在机器字长5位的情况下)

### 原码除法: 恢复余数法

符号位单独处理: 符号位 = **Xs⊕Ys**

数值位取绝对值进行除法运算

计算机默认在MQ低位上商 1 ,如果搞错了再改上商 0 ,并"恢复余数"

ACC , MQ 整体"逻辑左移".ACC高位丢弃,MQ低位补0

### 原码除法: 加减交替法(不恢复余数法)

恢复余数法: 当余数为负时商 0 ,并 +|除数|, 再左移, 再-|除数|
加减交替法: 当余数为负时商 0,并左移, 再 +|除数|

### 补码除法: 加减交替法

- 符号位参与运算
- 被除数/余数,除数都采用双符号位

被除数和除数同号,则被除数减去除数
异号则被除数加上除数

余数和除数**同号**,商 **1** , 余数**左移一位减去除数**;
余数和除数**异号**,商 **0** , 余数**左移一位加上除数**

重复n次

**末位商恒定置为1**

## 浮点数运算

步骤: 

1. 对阶
2. 尾数加减
3. 规格化
4. 舍入(保留限定位数的尾数)
5. 判断溢出

# 第三章 指令系统

指令(又称作机器指令): 是指示计算机执行某种操作的命令,是计算机运行的最小功能单位

一台计算机的所有指令的集合构成该计算机的**指令系统**,也称为**指令集**

> 一台计算机只能执行自己指令系统中的指令,不能执行其他系统的指令
> 
> Eg: X86 架构,ARM 架构

一条指令就是机器语言的一个语句,它是一组有意义的二进制代码

一条指令通常要包括操作码字段和地址码字段

操作码(OP)  地址码(A)
用户的操作  对谁进行操作

## 指令地址

一条指令可能包含 0个,1个,2个....地址码
根据地址码的数目不同,可以将指令分为 零地址指令,一地址指令....

### 零地址指令 (OP  )

- 不需要操作数,如空操作,停机,关中断等指令
- 堆栈计算机,两个操作数隐含存放在栈顶和次栈顶,计算结果压回栈顶

### 一地址指令 (OP A1)

- 只需要单操作数,如加1,减1,取反,求补等 
  - 指令含义: OP(A1) -> A1 CPU首先从A1所指向的主存单元中取出相应的数据,然后对这个数据执行OP(操作符)所指明的相对应的操作,得到运算结果后把结果写回A1所指的存储单元
  - 完成一条指令需要三次访存: 取指令 -> 读A1 -> 写A1
- 需要两个操作数,但其中一个操作数隐含在某个寄存器中(如隐含在ACC中)
  - 指令含义: (ACC)OP(A1) -> ACC
  - 完成一条指令需要两次访存: 取指令 -> 读A1

> A1指某个主存地址,(A1)表示A1所指向的地址中的内容

### 二地址指令 (OP A1(目的操作数) A2(源操作数))

- 常用于需要两个操作数的算数运算,逻辑运算相关指令
  - 指令含义: (A1)OP(A2) -> A1
  - 完成一条指令需要四次访存: 取指令 -> 读A1 -> 读A2 -> 写A1

### 三地址指令 (OP A1 A2 A3(结果))

- 常用于需要两个操作数的算数运算,逻辑运算相关指令
  - 指令含义: (A1)OP(A2) -> A3
  - 完成一条指令需要四次访存: 取指令 -> 读A1 -> 读A2 -> 写A3

### 四地址指令 (OP A1 A2 A3(结果) A4(下址))

- 指令含义: (A1)OP(A2) -> A3, A4=下一条将要执行指令的地址
  - 完成一条指令需要四次访存: 取指令 -> 读A1 -> 读A2 -> 写A3

正常情况下: 取指令之后PC+1,指向下一条指令
四地址指令: 执行指令后,将PC的值修改为A4所指的地址


n位地址码的直接寻址范围 = 2^n

若指令总长度固定不变,则地址码数量越多,寻址能力越差

`指令字长`: 一条指令的总长度(可能会变)
`机器字长`: CPU进行一次整数运算所能处理的二进制数据位数(通常与ALU直接相关)
`存储字长`: 一个存储单元中的二进制代码位数(通常和MDR位数相同)

## 数据寻址

`数据寻址`: 确定**本条指令**的**地址码指明的真实地址**
`形式地址`: 指令中的地址码字段称为形式地址

### 寻址方式

`直接寻址`: 指令字中的形式地址A就是操作数的真实地址EA 
- 优点: 简单指令执行阶段仅访问一次主存不需要专门计算操作数的地址
- 缺点: A的位数决定了该指令的操作数的寻址范围,操作数的地址不易修改

`间接寻址`: 指定地址字段给出的形式地址不是操作数的真正地址,二世操作数有效地址所在的存储单位的地址,也就是操作数地址的地址,即EA=(A)
- 优点: 可扩大寻址范围,便于编制程序
- 缺点: 指令在执行阶段要多次访存

`寄存器寻址`: 在指令字中直接给出操作数所在的寄存器编号,即EA=Ri,其操作数在由Ri所指的寄存器内
- 优点: 在执行阶段不访问主存,之访问寄存器,指令字短且执行速度快,支持向量/矩阵运算
- 缺点: 寄存器价格昂贵,寄存器个数有限

`寄存器间接寻址`: 寄存器Ri中给出的不是一个操作数,而是操作数所在主存单元的地址,即EA=(Ri)
- 优点: 比一般的间接寻址快

`立即寻址`: 形式地址A就是操作数本身,又称为立即数,一般采用补码形式 `#` 表示立即寻址特征
- 优点: 指令执行阶段不访问主存,指令执行时间最短
- 缺点: A的位数限制了立即数的范围,如A的位数为n,且立即数采用补码时,克表示的数据范围为 (-2^n-1)~(2^n-1)-1

**偏移寻址**

以某个地址作为起点,形式地址视为"偏移量"

`基址寻址`: 以程序的起始存放地址作为"起点"
`变址寻址`: 程序员自己决定从哪里作为"起点"
`相对寻址`: 以程序计数器PC所指地址作为"起点"

### 基址寻址

将CPU中的`基址寄存器(BR,base address register)`的内容加上指令格式中的形式地址A.而形成操作数的有效地址,即EA=(BR)+A

> 采用专用寄存器BR作为基址寄存器
> OS中的**重定位寄存器**就是**基址寄存器**
> 也有计算机内部没有专门的BR,而是使用通用寄存器作为基址寄存器,这时指令中需要给出寄存器的编号.根据通用寄存器的数量可以判断需要指令中需要几个bit来表示,如有8个通用寄存器,指令中需要3位来表示.

### 变址寻址

有效地址EA等于指令字中的形式地址A与`变址寄存器IX(index register)`的内容相加之和,即EA=(IX)+A,其中**IX可为变址寄存器(专用)**,也**可用通用寄存器作为变址寄存器**

变址寻址也可和间址寻址一起使用,根据执行顺序的不同分为以下两种

`前变址`: 先进行变址寻址然后再进行间址寻址 EA=((IX)+A)
`后变址`: 先进行间址寻址然后再进行变址寻址 EA=(IX)+(A)

### 相对寻址

把`程序计数器PC`的内容加上指令格式中的形式地址A而形成操作数的有效地址,即EA=(PC)+A,其中**A是相对于PC**所指地址的**位移量**,可正可负,**补码表示**

## 操作类型
指令系统的完备性要求在设计指令系统时必须考虑制冷系统应提供哪些操作类型,对大多数制冷系统考察后得知,操作类型按功能分为以下几种

### 算数和逻辑运算指令

这类指令有 加(ADD)减(SUB)比较(CMP)乘(MUL)除(DIV)与(AND)或(OR)取反(NOT)取负(NEG)异或(XOR)加1(INC)减1(DEC)等

### 移位指令

这类指令有算数移位,逻辑移位,循环移位,半字交换等


### 传送指令

传送指令通常有寄存器之间的传送(MOV),从内存单眼读取数据到CPU寄存器的(LOAD),从CPU寄存器写数据到内存单元(STORE)等

### 串指令

对于字符串进行操作的指令


### 顺序控制指令

用来控制程序执行的顺序

### CPU控制指令

这类指令有停机,开中断,关中断,系统模式切换以及进入特殊处理程序等指令.

### 输入输出指令

这类指令用于CPU与外部设备交换数据或传送控制命令以及状态信息.

## 操作码编码

`定长指令字结构`: 指令系统中所有指令的长度都相等
`变长指令字结构`: 指令系统中各种指令的长度不等

`定长操作码`: 指令系统中所有指令的操作码长度都相同
`可变长操作码`: 指令系统中各指令的操作码长度可变

定长指令字结构 + 可变长操作码 -> 扩展操作码指令格式

扩展操作码举例:

指令字长为 16 位,每个地址码4位,前4位为基本操作码字段OP,另有三个4位长的地址字段 A1,A2,A3

4位基本操作码若全用于三地址指令,则有16条
但至少须将1111 留作扩展操作码之用,即三地址指令为 15 条

1111 1111 留作扩展操作码之用,二地址指令为15条

1111 1111 1111 留作扩展操作码之用,一地址指令为15条

零地址指令为16条

还有其他扩展操作码设计方法

> 在设计扩展操作码指令格式时,必须注意以下两点
>
> 1. **不允许短码是长码的前缀**,即短操作码不能与长操作码的前面部分的代码相同
> 2. 各指令的操作码一定不能重复

通常情况下,对频率较高的指令,分配较短的操作码;对使用频率较低的指令,分配较长的操作码,从而尽可能减少指令译码和分析时间

### 指令系统设计风格

**按操作数位置指定风格来分**

1. 累加器(Accumulator)型指令系统: 这类指令系统中,总是把其中一操作数隐含在累加器中
2. 栈(stack)型系统: 栈是一种采后后进先出(LIFO)或先进后出(FILO)取方式的特定存储区
3. 通用寄存器(General Purpose Register)型指令系统: 特点是采用通寄存器而不是累加器存放运算过程中所用的临时数据
4. Load/Store型指令系统: 也是使用通用寄存器而不是累加器来存放运过程中所用的零食数据,但显著特点是,只有取(load)指令和存数(Store)令才可以访问存储器,运算类指令不能访存.

目前通用寄存器型指令系统占主导地位.

**按指令格式的复杂度来分**

- CISC(复杂指令集计算机Complex Instruction Set Computer)
  - 指令系统复杂: 指令多,寻址方式多,指令格式多
  - 指令周期长: 大多数指令需要多个时钟周期才能完成
  - 采用微程序控制: 由于有些指令非常复杂,以至于无法用硬连线控制器来实现,而微程序控制器用软件设计思想实现硬件,可以实现对复杂指令的控制
  - 难以进行编译优化: 由于编译器可选指令序列增多,使目标代码组合增加,从而增加了目标代码优化的难度
- RISC(精简指令集计算机Reduced Instruction Set Computer)
  - 指令条目少: 只包含使用频度高的指令
  - 指令格式规整: 寻址方式少,指令格式少,指令长度一致
  - 采用load/store型指令设计风格
  - 采用流水线方式执行指令: 规整的指令格式有利于采用流水线方式执行,除了Load/Store指令外,其他指令都只需一个或小于一个时钟周期就可以完成,指令周期短
  - 采用大量通用寄存器: 编译器可将变量分配到寄存器中,以减少访存次数
  - 采用硬连线控制器: 指令少而规整使得控制器的实现变得简答,可以不用或少用微程序控制
  - 采用优化的编译系统: 指令数少有利于编译器的优化

## MIPS指令集与其汇编语言

### 指令格式和寻址方式

MIPS 是典型的RISC结构,按字节编址,采用32位定长指令字,操作码字段也是固定长度,没有专门的寻址方式字段,由指令格式确定各操作数的寻址方式

MIPS指令采用三地址指令格式,只有三种类型

- R - 型指令:
格式: OP  rs  rt  rd  shamt  funct

这类指令的两个操作数和结果都存放在寄存器中,其操作码OP为"000000",造作类型由funct字段指定.

寻址方式只有一种: 寄存器直接寻址

- I - 型指令:
格式: OP  rs  rt  立即数

如果是双目运算类指令,则将rs内容和立即数分别作为第一和第二源操作数,结果送rt

寻址方式有四种: 寄存器直接寻址,立即数寻址,相对寻址,基址或变址寻址

- J - 型指令
格式: OP  直接地址

主要是无条件跳转指令,指令中给出的是 26 位直接地址,只要将PC的高四位拼上26位直接地址,最后添两个"0"就可以得到32位的跳转目标地址

寻址方式只有一种: 变通的直接寻址

### MIPS中数据的表示

1. MIPS指令中的操作数可以是立即数,或是通用寄存器的内容,也可以是存储单元的内容
2. MIPS处理器提供了32 个 32位通用寄存器,因此寄存器编号占5位. 例如R型指令格式中的rs,rt,rd和I型指令格式中的rs,rt都是指通用寄存器.

> 0号寄存器总是为0 , 31号寄存器用于存放过程调用的返回地址

寄存器的汇编表示以`$`符号开始,可以使用名称(如$a0),也可以使用编号(如$4)

3. MIPS还提供了32个32位的单精度浮点寄存器,用汇编符号$f0~$f31表示,他们可以配对成16个64位浮点寄存器,用来表示64位双精度浮点数
4. MIPS中提供了两个乘商寄存器Hi和Lo,他们无需程序员在指令中显式给出.用32位的Hi和Lo可实现一个64位寄存器.
5. MIPS中用程序计数器PC指出下一条指令的地址
6. MIPS的存储器按字节编址.对于存储器数据,其操作数地址为32位,通过一个32位寄存器的内容加16位偏移量得到.其中,32位寄存器就是I型指令中的rs,16位偏移量就是I型指令中的16位立即数,通常是一个带符号整数,因而,存储器操作数可访问的地址空间大小为 2^32字节
7. MIPS采用大端方式(Big Endian)存放数据,数据要求按字边界对齐.只能通过Load/Store指令访问存储器数据.
8. 对于立即操作数,指令中给出的位数为16位,指令执行时,需要将其进行符号扩展或0扩展,变成32位操作数后才能参加运算.

常用的5类指令: 算数运算,存储访问,逻辑运算,条件分支,无条件转移

1. 算数类指令包括算数运算和逻辑运算指令,它们可以是R-型格式指令,也可以是I-型格式指令 如:"sub $s1,$s2,$s3"的含义为"$s1 = $s2-$s3"

I-型格式运算类指令的汇编表示有一个特点,就是指令操作助记符总是以i结尾,而且第二个源操作数一定是一个立即数 如:"andi $s1,$s2,100"的含义为"$s1 = $s2&100"

2. 逻辑运算指令中还包括了逻辑左移sll和逻辑右移srl 如:"srl $s1,$s2,10"的功能为 "$s1 = $s2>>10" 含义为: 将寄存器$s2中的内容逻辑右移10位后送至寄存器$s1中,逻辑右移操作的实现方式为: 低位移出,高位补0

3. 存储访问类的指令有两种,一种是装入(Load)指令,另一种是存储(Store)指令 如:"lw $s1,100($s2)"的含义是,将存储单元中一个32位数据装入到通用寄存器$s1中,存储单元的首地址为$s2的内容加上100,因此,这里$s1,$s2和100分别是I-型指令中的rs,rt和16位立即数

4. 条件分支类指令包括条件设置指令(如 slt)和分支指令(如 beq,bne).条件设置指令slt用于比较两个寄存器内容的大小,或者将某个寄存器内容与一个立即数比较,前者为R-型格式指令,后者为I-型格式指令 如: R-型格式指令 "slt $s1,$s2,$s3"用于判断寄存器$s2和$s3内容的大小,若"小于"则$s1=1,否则$s1=0

分支指令beq,bne分别用于判断两个寄存器内容是否相等,不等,并更具判断结果确定是否转移到目标指令处执行,他们都是I-型格式指令,转移目标地址采用相对寻址方式,即转移目标地址=(PC)+偏移量,指令的16位立即数就是偏移量

5. 无条件跳转指令包括j,jal和jr等几条指令,j指令执行后,将直接跳转到转移目标地址;jal指令用于过程调用,在其执行过程中,将先把当前PC的内容(jal指令下条指令的地址)作为返回地址,保存到31号寄存器$ra中,然后再跳转到转移目标地址;jr指令用于过程返回,该指令将从31号寄存器$ra中取出返回地址,将其作为转移目标地址进行跳转

## 程序的机器级表示

1. 选择结构的机器代码表示
2. 循环结构的机器代码表示

# 第四章 中央处理器

## 程序的执行概述

`指令周期`: CPU取出并执行一条指令的时间

CPU执行一条指令的大致过程是: 取指令,指令译码,计算源操作数地址并取操作数,执行数据操作,计算目的操作数地址并存结果,计算下条指令地址

1. 取指令: 取指令的操作就是从PC所指出的存储单元中取出指令送到指令寄存器(IR)
2. 指令译码: CPU根据不同的指令**操作码**译出不同的控制信号
3. 计算源操作数地址并取操作数: 若源操作数是寄存器中的数据,则直接从寄存器取数后,转到下一步进行数据操作.若是存储器操作数,则需要访问存储器.在访存之前,需要根据**寻址方式**确定源操作数地址计算方式
4. 数据操作
5. 目的操作数地址计算并存结果
6. 指令地址计算并将其送PC

## CPU的基本功能和基本组成

CPU的基本职能: 就是周而复始的执行指令,机器指令执行过程中的全部操作都是由CPU中的控制器控制执行的

CPU最基本部件: 数据通路(datapath)和控制部件(control unit)

### CPU的基本组成

1. `程序计数器(PC)`: PC又称指令计数器或指令指针寄存器(IP),用来存放即将执行指令的地址
2. `指令寄存器(IR)`: IR用以存放现行指令
3. `指令译码器(ID)`: 指令译码器对指令寄存器中的操作码部分进行分析解释,产生相应的译码信号提供给操作控制信号形成部件,以产生控制信号
4. `启停控制逻辑`: 启停控制逻辑控制时序型号的发生与停止,并实现对机器的启动与停机

5. `时序信号产生部件`: 该部件以时钟脉冲为基础,产生不同指令对应的周期,节拍,工作脉冲等时序信号,实现机器指令执行过程的时序控制
6. `操作控制信号形成部件`: 该部件综合时序信号,指令译码信号和执行部件反馈的条件标志(如 CF,SF,OF等),形成不同指令的操作所需要的控制信号
7. `总线控制逻辑`: 实现对总线传输的控制,包括对数据和地址信息的缓冲与控制,其中包括用来缓存数据信息的存储器数据寄存器MDR和用来缓存地址信息的存储器地址寄存器MAR.CPU对于存储器的访问通过总线进行,CPU将存储访问命令(即读写控制信号)送到控制线,将要访问的存储单元地址送到地址线,并通过数据线取指令或者与存储器交换数据信息
8. `中断机构`: 实现对异常情况和外部中断请求的处理 

### 打断程序正常执行的事件

1. 对指令操作码进行译码时,发现是不存在的"非法操作码"
2. 在访问指令或数据时,发现尧都区的指令和数据不在主存中
3. 在ALU中运算的结果发生溢出,或者整数除法指令的除数为0
4. 在执行的过程中,CPU外部发生了采样计时是按到,网络数据包到达网络适配器,磁盘完成数据读写等外部事件,要求CPU中止当前程序的执行,专去执行专门的外部事件处理程序

**基本概念**

`异常控制(中断机制)`: CPU除了能正常执行指令以外,还必须具有程序正常执行被打断时的处理机制
`中断机构`: CPU中相应的异常和中断处理逻辑

**异常和中断**

所有这些打断程序正常执行的事件被分为两大类: 异常和中断

`异常`: 异常指是由CPU内部的异常引起的意外事件

  1. 硬故障中断是由于硬连线路出现异常而引起的,如电源掉电,校验线路错等
  2. 程序性异常是由CPU执行某条指令而引起的发生在CPU内部的异常事件.如除数为0,溢出,断点,单步跟踪寻址错,访问超市,非法操作码,栈溢出,缺页,地址越界(段错误)等

`中断`: 程序执行过程中,若外设完成任务或发生某些特殊事件,设备控制器会向CPU发中断请求,要求CPU对这些情况进行处理.这类事件与执行的指令无关,由CPU外部的I/O硬件发出,所以,称为I/O中断或外部中断,需要通过外部中断请求线向CPU请求

## 数据通路基本结构和定时

`数据通路`: 指令执行过程中数据所经过的路径,包括路径上的部件
`执行部件或功能部件`: 数据通路中专门进行数据运算的部件

数据通路由控制部件发出的控制信号进行控制

指令执行用到的元件有两类: 组合逻辑元件(也称操作元件)和时序逻辑元件(也称状态元件或存储元件)

连接这些元件的方式有两种: 总线方式和分散连接方式

数据通路就是由组合逻辑元件和时序逻辑元件通过总线或分散方式连接而成的进行数据存储,处理和传送的路径

`操作元件`: 组合逻辑元件的输出只取决于当前的输入.若输入一样,其输出也一样.组合电路的定时不受时钟信号的控制,所有输入信号到达后,经过一定的逻辑门延迟,输出端的值呗改变,并一直保持其值不变,直到输入信号改变

`状态元件`: 状态元件具有存储功能,输入状态在时钟控制下被写到电路中,并保持电路的输出值不变,直到下一个时钟到达.输入端状态由时钟决定何时被写入,输出端状态随时可以读出

**数据通路的时序控制**

早期计算机的定时方式

通常采用机器周期,节拍和脉冲三级时序对数据通路操作进行定时控制

现代计算机的定时方式

现代计算机中,整个数据通路中的定时信号就是时钟信号,一个时钟周期就是一个节拍,CPU的主频就是时钟信号的频率

## 数据通路基本工作原理

单总线数据通路结构中,几种基本操作过程

1. 在通用寄存器之间传送数据

 如 要将寄存器R0的内容传送到寄存器Y,则对应的控制信号取值为: R0out=1,Yin=1,其余寄存器的Rin和Rout信号都为0

 通常称取值为1的Rin和Rout信号为有效控制信号,在描述控制信号取值时,止泄出有效控制信号,如"R0out,Yin"

2. 完成算数逻辑运算

  ALU运算的其中一个操作数来自Y寄存器,另一个操作数被置于总线上,运算结果被临时存放在寄存器Z中

  例如: 完成指令"R[R3] <- R[R1] + R[R2]"的有效控制信号如下

  R1out,Yin
  R2out,add,(Zin)
  Zout,R3in

任何时刻只能将一个寄存器的内容送到内总线,任何异步结束时结果要送到某个寄存器的输入端(即保存到寄存器).因此,该操作需要三个时钟周期(节拍)

3. 从内存单元读取一个字
早期的计算机,CPU和主存之间采用"异步"方式进行通信

假定需要在某条指令中实现操作R[R2] <- M[R[R1]] 控制信号序列如下

  R1out,MARin
  read,WMFC
  MDRout,R2in

4. 把一个字写入内存单元

  M[R[R2]] <- R[R1]

  R1out,MDRin
  R2out,MAR
  write,WMFC

`单周期处理器`是指其所有指令的指令周期都为一个时钟周期,`单周期数据通路`既是单周期处理器中的数据通路.在单周期数据通路中,所有操作都需要在一个时钟周期内完成

## 流水线方式下指令的执行

一条指令的执行可被分为若干个阶段,每个阶段都在相应的功能部件中完成,如果将各阶段看成相应的流水段,则指令的执行过程就构成了一条指令流水线. 如,假定一条指令流水线由以下5个流水段组成

取指令(IF): 根据PC的值从存储器取出指令并更新PC
指令译码(ID): 产生指令执行所需的控制信号
取操作数(OF): 读取存储器操作数或寄存器操作数
执行(EX): 对操作数完成指定操作
写回(WB): 将操作结果写入存储或寄存器

MIPS指令系统中最复杂的指令需要5个阶段完成操作,因此,MIPS指令流水线数据通路通常用一个五段流水线实现,其执行过程和功能段划分如下

取指(Ifetch): 取指令并PC加4(MIPS每条指令占32位,4单元)
译码/取数(Reg/Dec): 读取寄存器内容并对指令译码
执行(Exec): 进行算数运算或逻辑运算(包括传送操作)
访存(Mem): 存储器读数或写数据
写回(Write): 选择存入寄存器的结果并将其在寄存器输入端稳定保持一段建立时间

适合流水线的指令集特征

1. 指令长度尽量一致
2. 指令格式尽量规整,尽量保证源寄存器的位置相同
3. 采用Load/stor型指令风格
4. 为了便于以流水线方式执行指令,数据和指令在存储器中要"对齐"存放

## 控制器设计基本原理

`控制器`: 是整个CPU的指挥控制中心,也称为控制部件,控制逻辑或控制单元,作用是对指令进行译码,将译码结果和状态/标志信号,时序信号等进行组合,产生指令执行过程中所需要的控制信号

`控制信号`: 用于控制数据通路中信息的流动

根据不同的控制描述方式,可以有硬连线控制器和微程序控制器两种实现方式

