# 第一章
## 计算机系统的基本组成

**基本思想/结构特点**

1. 使用“存储程序”工作方式
2. 计算机由运算器,控制器,存储器,输入设备和输出设备5个基本部件组成
3. 存储器不仅能存放数据,而且也能存放指令,形式上数据和指令没什么区别,但计算机能区分它们; 控制器应能控制指令的自动执行; 运算器应能进行加减乘除四种基本算数运算,并且也能进行逻辑运算; 操作人员可以通过输入输出设备使用计算机
4. 计算机内部以二进制形式表达指令和数据; 每条指令由操作码和地址码两部分组成,操作码指出操作类型,地址码指出操作数的地址; 由一串指令组成程序

`硬件`: 计算机硬件主要包括中央处理器,存储器,I/O控制器,外部设备和总线等,是物理装置的总称

`软件`: 运行在硬件上的程序和数据以及相关的文档

`程序`: 是指挥计算机如何操作的一个**指令序列**,即程序由指令组成

`指令`: 是计算机硬件能够直接理解并执行的最**基本操作**

`数据`: 是指令操作的对象

`存储程序方式`: 将编制好的程序（由若干相应的指令构成）存入计算机的存储器,当计算机工作时,能自动的逐条取出指令并执行

`IAS计算机`: “存储程序” 计算机

**现代计算机的基本组成:**

硬件部分: 

- `中央处理器`（Central Processing Unit,CPU）有时简称为处理器,是整个计算机的核心部件,主要用于指令的执行。CPU主要包含两种基本部件**数据通路**和**控制器**。

  - `数据通路`主要包含**算数逻辑部件(ALU)**和**通用寄存器**等,其功能是用来执行算数和逻辑运算等操作。

  - `控制器`用来对指令进行**译码**,生成相应的控制信号,以控制数据通路进行正确的操作

- `存储器`分为**内存**和**外存**,
  
  - `内存`包括`主存储器`(main memory,简称主存)和`高速缓存`(cache)

  - `外存`包括`辅助存储器`和`海量后备存储器`.通常把系统运行时直接和主存交换信息的存储器称为辅助存储器,简称辅存,目前主要的辅助存储器是磁盘存储器和固态硬盘

- `外部设备`简称为外设,也成为`I/O设备`,I/O是输入输出(Input/Output)的缩写.外设通常由机械部分和电子部分组成,而且两部分通常是可以分开的,机械部分是外部设备本身,而电子部分则是控制外部设备的`I/O控制器或I/O适配器`,外设通过`I/O控制器或I/O适配器`连接到主机上,`I/O控制器或I/O适配器`统称为设备控制器

- `总线`(bus)是传输信息的介质,用于在部件之间传输信息,CPU,主存和I/O模块通过总线互联,在CPU和I/O模块中都内涵相应的存储部件,即**缓存器**

`ALU`是数据处理部件,用于执行数据的算数和逻辑运算,ALU处理的数据来自**寄存器堆**;

`磁盘和主存`是存储部件,分别用于存储长期保存信息和临时保存信息;

`各类总线以及总线接口部件`,I/O桥接器,I/O扩展槽,I/O控制器和显示适配器等都是互联部件,用于完成数据传送任务

所有这些部件的操作都通过`CPU`中的`控制器`对指令**译码**后送出的**控制信号**的控制来完成

## 计算机软件

- 软件
  - 系统软件
    - 操作系统
    - 语言处理程序(编译器)
    - 数据库管理系统(DBMS)
    - 实用程序(磁盘碎片整理等)
  - 应用软件: 专门为某些应用比所编写的各类程序

## 计算机系统的层次结构

```
    应用(问题)
    算法
    编程(语言)
    操作系统/虚拟机
    指令集体系结构(ISA)
    微体系结构
    功能部件/RTL
    电路
    器件
```

`汇编程序(assembler)`: 也称汇编器,用来将汇编语言源程序翻译成机器语言目标程序

`解释程序(interpreter)`: 也称解释器,用来将源程序中的语句按其执行顺序逐条翻译成机器指令并立即执行

`编译程序(compiler)`: 也称编译器,用来将高级语言源程序翻译成汇编语言或机器语言目标程序

`指令集体系结构(ISA)`: 机器语言程序所运行的计算机硬件和软件之间需要有一个"桥梁",这个在软件和硬件之间的界面就是指令集体系结构(Instruction Set Architecture,ISA),简称体系结构或系统结构(architecture),他是软件和硬件之间接口的一个完整定义.ISA定义了一台计算机可以执行的所有指令的集合,每条指令规定了计算机执行什么操作,所处理的操作数存放的地址控件以及操作数类型.

`微体系结构`: ISA是对指令系统的一种规定或结构规范,具体实现的组织(organization) 称为微体系结构(microarchitecture)简称微架构. 相同的ISA可能会具有不同的微体系结构

## 计算机系统的不同用户

`最终用户`: 使用应用程序完成特定任务的计算机用户

`系统管理员`: 指利用操作系统等软件提供的功能对系统进行配置,管理和维护,以建立高效合理的系统环境供计算机用户使用的操作人员

`应用程序员`: 指使用高级编程语言编制应用软件的程序员

`系统程序员`: 指设计和开发系统软件的程序员

## 程序开发和执行过程

假设有一个 hello.c 的文件

将 hello.c 进行预处理,编译,汇编和链接,最终生成可执行目标文件.例如在UNIX系统中可用GCC编译驱动程序进行处理

```
hello.c(C源程序)   预处理程(cpp)   hello.i(预处理后的源程序)   编译程序(ccl)   hello.s(汇编源程序)   汇编程序(as)   hello.o(可重定位目标程序)   链接程序(ld)   hello(可执行目标程序)
```

## 指令执行的过程

`通用寄存器组`: 用来存放操作数或操作数的地址

`标志寄存器`: 用来存放ALU运算得到的一些标志信息

`程序计数器(PC)`: 用来存放将要执行的下一条指令的地址

`指令寄存器(IR)`: 用来存放从主存中读出的指令

`主存地址`: 每个存储但愿的一个唯一编号

`存储地址寄存器(MAR,memory access register)`: 用来存放当前CPU所访问的内存单元的地址

`存储数据寄存器(MDR,memory data register)`: 用来存放CPU与主存储器交换的数据

可执行目标文件中包含机器代码段

机器代码段由一条一条指令构成

程序被启动后,CPU通过逐条执行程序中的指令来实现程序的功能

**执行过程**

1. 根据PC取指令到IR
2. 指令译码并送出控制信号
3. 取操作数
4. 执行指令
5. 写回结果

PC更新: 为了能自动执行程序中的指令 CPU必须能够自动得到下一条指令的地址并送PC,所以取出指令送到IR稳定后,PC自动更新

定长指令字系统: 每条指令的长度都一样
          PC = PC + 指令长度(相同值)

变长指令字系统: 每条指令的长度不一样
          PC = PC + 指令长度(不同值)

`指令周期`: 从一条指令的启动到下一条指令的启动之间的间隔时间 

`机器周期`: 是指令执行中每一步操作所需的时间.一般以CPU中完成一个原运算操作所需的时间作为机器周期的基本时间,机器周期也叫CPU周期

`时钟周期`: 指计算机的主频周期,也成为T周期或T状态

## 计算机系统性能评价

`吞吐率(带宽)`: 表示在单位时间内所完成的工作量
`响应时间(执行时间或等待时间)`: 是指从作业提交开始到作业完成所需要的时间

`CPU时间`: 指CPU用于程序执行的时间,包括用户CPU时间和系统CPU时间
  - 用户CPU时间: 指真正用于运行用户程序代码的时间
  - 系统CPU时间: 指为了执行用户程序而需要CPU运行操作系统程序的时间

在对用户CPU时间进行计算时需要用到的指标:
1. `时钟周期`: 用于对控制信号定时的同步信号即为CPU的时钟信号,其宽度为一个时钟周期
2. `时钟频率`: CPU的主频 等于**1/CPU时钟周期** 与时钟周期互为倒数关系 单位为 Hz  1S / 时钟周期 = 时钟频率Hz 
3. `CPI(Clock cycle Per Instruction)`: 执行一条指令所需的时钟周期数

执行一条指令的耗时 = CPI x CPU时钟周期

CPU的执行时间 = 程序所含时钟周期数/时钟频率 = 程序所含的时钟周期数x时钟周期

如果已知程序总的指令条数和综合CPI,则可以使用如下公式计算程序的时钟周期数

程序总时钟周期数 = 程序所含指令条数 x CPI

`IPS(Instructions Per Second)`: 每秒执行多少条指令  IPS = 主频(时钟频率)/平均CPI

`MIPS`: 平均每秒执行多少百万条(10^6)指令

`FLOPS(Floating-point Operation Per Second)`: 每秒钟可以执行多少次浮点运算

指令平均时间(等效指令速度法或Gibson混合法): 等效质量的执行时间 T = W1 x T1 + W2 x T2 ... + Wn x Tn

其中:
Wi 为某类指令i在程序中所占比例
Ti 为执行时间
n  为指令种类数

1. 若指令的执行时间用时钟周期数衡量,T就是CPI
2. 指令平均执行时间的倒数就是MIPS值
3. `峰值MIPS`: 选取一组指令组合,使得得到的平均CPI最小,则其倒数就是峰值MIPS
4. 相对MIPS是根据某个公认的参考机型来定义相应MIPS值其值的含义是北侧机型相对于参考机型MIPS的多少倍
5. MIPS反应机器执行**定点指令**的速度,但是,用MIPS来对不同的机器进行性能比较有时是不准确或不客观的

`基准程序`: 专门用来进行性能评价的**一组程序**

SPEC测试程序集应用最广泛,也是最全面的性能评测基准程序集

## 总结

**难点**

1. 冯诺依曼计算机结构特点
2. 计算机的硬件组成
3. 计算机的工作过程
4. 计算机系统的层次结构
5. 计算机系统基本性能指标及性能评估

# 第二章 数据的表示和运算

## 数制和编码

`进位制`: 表示数时,仅用一位数码往往不够用,必须用进位计数的方法组成多位数码.多为数码每一位的构成以及从地位到高位的进位规则称为进位计数制简称进位制

`数值数据`: 用来表示数量的多少,可比较大小,分为整数和实数,整数又分为无符号和带符号两种

`非数值数据`: 没有大小之分,不表示数量的多少,主要包括字符数据和逻辑数据

`基数`: 进位制的基数,就是在该进制值中可能用到的符号个数

`位权(位的权数)`: 在某一进位制的数中,每一位的大小都对应着该位上的数码乘一个固定的数,这个固定的书就是这一位的权数.权数是一个幂

为什么使用二进制

1. 只有两种基本状态,容易使用物理器件表示
2. 编码,计数,运算都很简单,可使用开关电路实现
3. 两个符号刚好对应真,假,可以方便的实现逻辑判断,也能通过逻辑门电路实现算数运算

**十进制转换成R进制**
整数部分: 除基取余,上右下左
小数部分: 乘基取整,上左下右

## 整数的表示

`定点数`: 小数点的位置是固定的

`浮点数`: 小数点的位置根据需要可以左右移动

`定点整数`: 整数的小数点隐含在数的最右边,不需要表示小数点

`定点小数`: 整数的小数点隐含在最高数位的左边,不需要表示小数点

二进制整数分为无符号整数(unsigned integer)和带符号整数(signed integer)两种

`无符号整数`: 一个编码的所有二进制位都用来表示数值而没有符号位

`带符号整数`: 必须用一个二进制位来表示符号,也称为有符号整数

计算机系统中一般整数使用补码表示,优点为以下

1. 与原码和反码相比, 0 的补码表示形式唯一
2. 与原码和移码相比,补码运算系统是一种模运算系统,因而可用假发实现减法运算,且符号位可以和数值位一起参与运算
3. 与原码和反码相比,它比原码和反码多表示一个最小负数
4. 与反码相比,不需要通过循环进位来调整结果

### 原码/反码/补码

1. 符号位"0/1"对应"正/负",剩余的数值为表示真值的绝对值
2. 若机器字长n+1位,带符号整数的原码表示范围: -(2^n-1) <= x <= 2^n-1
3. 真值0有两种形式: +0 和 -0 [+0]原 = 0,0000000 [-0]原 = 1,0000000

缺点: **符号位不能参与运算**,需要设计复杂的硬件电路才能处理,成本很高.

用补码表示真值--**符号位可以参与运算**

对于正数 原码--反码--补码  都一样,不变
对于负数 原码<->[符号位不变,数值位取反]<->补码->[末位+1]->补码

例: 
+19  三码都为 00010011
-19  三码各为 10010011 11101100 11101101
-100 三码各为 11100100 10011011 10011100

> 三码最高位都为符号位信息

> 原码快速转换为补码: **从右往左找到第一个1,这个1左边的所有"数值位"按位取反**
> 反过来将补码转换为原码也一样

计算机硬件如何做**补码**的**加法**:从最低位开始,**按位相加(符号位参与运算)**,并往更高位**进位**

> 补码的数值位不能解读为**位权**

>将一个正数的补码快速转换为正数负值:**从右往左找到第一个1,这个1左边的所有位按位取反**

### 移码

补码的基础上将符号位取反 **注意: 移码只能用于表示整数**

移码的定义: 移码 = 真值 + **偏置值**

此处8位移码的偏置值 128D = 10000000B ,即 2^(n-1)

## 实数的表示

计算机中专门用浮点数来表示实数

浮点数的格式 

```
X = (-1)^s*M*R^E
```

S: 用来决定数X的符号,一般用 0 表示正 , 1 表示负
E: 阶码,为定点整数,常用补码或移码表示,阶码的位数决定数的范围
M: 尾数,为定点小数,常用补码或原码表示,位数的位数决定数的精度
R: 阶码的底,一般选择与尾数的基数相同,隐含表示

为了浮点数表示的唯一性和提高精确度,需要将非规格化的数据转换为规格化

`规格化`: 规定尾数的最高位必须是一个有效值.

### IEEE 754标准

提供了两种基本浮点数格式: 32位单精度和64位双精度

32位单精度: 1位符号位 8位阶码 23位尾数
64位双精度: 1位符号位 11位阶码 52位尾数

1. 基数隐含为 2
2. 尾数用**原码**表示,第一位总为1,因此可在尾数中缺省第一位的1,称为**隐藏位**,使得单精度格式的23位数实际上表示了24位有效数字,双精度格式的52位尾数实际上表示了53位有效数字
3. 阶用移码表示.
4. 阶码E的范围,对于单精度来说范围是 -126~127

> IEEE 754 规定隐藏位 "1" 的位置在小数点之前

形成 IEEE754 浮点数步骤

1. 规格化二进制数: 改变阶码,使小数点前面仅有第一位有效数字(1)
2. 计算阶码: 利用偏移值表示法,实际指数加上偏移值
3. 单精度的阶码加上偏移量 7FH (127)
4. 双精度浮点数的阶码加上偏移量 3FFH(1023)
5. 把数值的符号位,阶码和尾数组合在一起就得到了该数的浮点存储形式

例:

十进制 -9/16 转换为 IEEE754

1. 转换为二进制为 -0.1001B
2. 计算阶码 -1.001x2^-1 阶码为 -1
3. 计算阶码偏移量 -1 + 127 = 126 转换为8位二进制 01111110
4. 尾数补齐23位 001 0000 0000 0000 0000 0000
5. 符号位 负数为 1
6. 二进制表示为 1011 1111 0001 0000 0000 0000 0000 0000
7. 十六进制表示为 BF 10 00 00 H

机器数 C0 A0 00 00H 转换为 IEEE754单精度浮点数

1. 转换为二进制表示 1100 0000 1010 0000 0000 0000 0000 0000
2. 取出各位 1 10000001 010000000000000000000000
3. 计算阶码 10000001 转为十进制 129 - 127 = 2
4. 取出尾数转为十进制计算 0.01B = 0.25
5. 最终值为 -1 * 1.25 * 2 ^ 2 = -5.0

## 非数值数据的编码表示

逻辑值: 逻辑数据只能参加逻辑运算,并且是按位进行的

逻辑数据和数值数据都是一串 1 / 0 序列,在形式上没有任何差异,需要通过指令的操作码类型来识别他们.

西文: 由拉丁字母,数字,标点符号以及一些特殊符号所组成,统称为字符(character)
字符集: 所有字符的机核
码表: 字符集中每一个字符都有一个代码,构成了该字符集的代码表,简称码表

ASCII码(美国标准信息交换码): 每个字符由7个二进制位表示,其中B6-B4为高位,B3-B0是低位部分. 一个字符在计算机中实际上用8位表示,一般情况下最高位的B7为0,需要奇偶校验的时候可以用B7这位来当作奇偶校验位

汉字的输入码: 每个汉字用一个或者几个键来表示,这种对每个汉字用对应的按键进行的编码表示就是输入码,又称为外码
字符集与汉字内码: 在系统中进存储,查找,传送处理的一种编码方式

## 数据的宽度和存储

比特(bit): 进制数据的每一位(0/1)是组成二进制信息的最小单位,称为一个"比特",或"位元",简称"位".比特是计算机中处理,存储和传输信息的最小单位
字节(byte): 一个字节等于8个比特.在计算机内部二进制信息的计量单位是字节(byte)
字(word): 用来表示被处理信息的单位,用来度量各种数据类的宽度

存储容量的单位主要有

1KB = 1024字节
1MB = 2^20字节
1GB = 2^30字节
1TB = 2^40字节
1PB = 2^50字节
1EB = 2^60字节
1ZB = 2^70字节

大端(big endian)存储方式: 将数据的最高有效字节MSB存放在最小地址单元中,将最低有效字节LSB放在最大地址单元中
小端(little endian)存储方式: 将数据的最高有效字节MSB存放在最高地址单元中,将最低有效字节LSB放在最低地址单元中,intel 80x86

例题: 假定 int变量 i 的地址为 0800H 机器数为 01 23 45 67 H 则I所占的存储单元的地址为 0800H 0801H 0802H 0803H 写出大端和小端方式下的存储结果

大端:  0800H-01 0801H-23 0802H-45 0803H-67
小端:  0800H-67 0801H-45 0802H-23 0803H-01

## 数据校验码

**奇偶校验**

奇偶校验: 原理是在K 位的信息码中增加一位校验位代码,使 k+1 位码字中取值为 1 的个数总保持为偶数(偶校验)或奇数(奇校验)

如假设信息码为 0110101 要使用奇校验的情况就是在高位添加 0或者1 案例情况为 1 0110101

常用于内存

**海明校验**

原理是将数据按照某种规律分成若干组,对魅族进行相应的就检测,以提供多位校验信息,从而可对错误位置进行定位,并将其纠正

编码过程

1. 确定校验位的位数

假定被校验数据M的位数为n,校验位P为k位,则n和k必须满足下列关系: 2^k >= 1+n+k 即 2^k-1 >= n+k

2. 确定分组方式

数据为和校验位是一起被存储的,通过将他们中的各位按某种方式排列为一个(n+k)位的码字,将该码字中每一个出错位置与故障字的数值建立挂你先,这样就可通过故障字的值很快确定是该码字中的哪一位发生了错误,从而将其取反来进行纠正

3. 故障字的值

- 如果故障字各位全部是0,则表示没有发生错误
- 如果故障字中有且仅有一位为 1 则表示校验位中有一位出错,不需要纠正
- 如果故障字中多位为1,则表示有一个数据位出错,其在码字中的出错位置由故障字的数值来确定.纠正时只需要将出错位取反即可

单纠错码(SEC)
单纠错/双检错码(SEC-DED)

**循环冗余校验**

(Cyclic Redundancy Check) 简称CRC码,是一种具有较强检错,纠错能力的校验码,常用于外存储器的数据校验,在计算机通信中也被广泛采用

## 加法器和算术逻辑部件

基本的运算部件是 加法器,ALU,移位器,ALU的核心部件是加法器

全加器: 同时考虑两个加数和低位进位的一位加法器被称为全加器(Full Adder, 简称FA)

加法器(无符号数加法器): n位的加法器可由n个全加器实现,其中Ci是第I-1位向第i位的进位

4位补码计算

-7 + -6

转无符号原码：0111 0110
转无符号补码：1001 1010
无符号补码加：0011
补码值：-3
转无符号原码： 1101
真值：-13

## 定点数的移位运算

### 原码的算数移位

符号位保持不变,仅对数值位进行移位

右移: 高位补0,低位舍弃.若舍弃的位=0,则相当于/2;若舍弃的位!=0,则会**丢失精度**
左移: 低位补0,高位舍弃.若舍弃的位=0,则相当于*2;若舍弃的位!=0,则会**严重误差**

### 反码的算数移位

正数的反码和原码相同,因此对**正数反码的移位运算也和原码相同**

右移: 高位补0,低位舍弃
左移: 低位补0,高位舍弃

负数的反码数值位与原码相反,因此负数反码的移位运算规则如下

右移: 高位补1,低位舍弃
左移: 低位补1,高位舍弃

### 补码的算数移位

正数的补码和原码相同,因此对**正数补码的移位运算也和原码相同**

右移: 高位补0,低位舍弃
左移: 低位补0,高位舍弃

负数的补码=反码末位+1,导致反码最右边几个连续的1都因为进位而变为0,知道进位碰到第一个0为止

**规律--负数补码中,最右边的1及其右边同原码,最右边的1的左边同反码(取反)**

右移(同反码): 高位补1,低位舍弃
左移(同原码): 低位补0,高位舍弃

### 总结

正数的 三码 左右移 添补代码都为0

负数的 原码 左右移 添补代码都为0

负数的 反码 左右移 添补代码都为1

负数的 补码 左移低位补0 右移高位补1

左移相当于 *2 右移相当于 /2

由于位数有限,因此有时候无法用算数移位精确的等效乘除法

### 逻辑移位

逻辑右移: 高位补0
逻辑左移: 低位补0

与无符号数移位操作基本一样

### 循环移位

循环移位: 用移出的位补上空缺
带进位位的循环移位: 移出的位放到进位位,用原进位位补上空缺

## 定点乘法

### 原码一位乘法

每次参与运算的只有一个位

符号位单独处理: 符号位 = Xs⊕Ys

数值位**取绝对值**进行乘法计算

例. 设机器字长n+1 = 5位(含1符号位),[x]原 = 1.1101 [y]原 = 0.1011,采用原码一位乘法求 x*y

符号位为: 0⊕1 = 1 负数
数值位取绝对值进行二进制乘法: [|x|]原 = 0.1101,[|y|]原 = 0.1011

> 乘数的符号位不参与运算,可以省略
> **原码**一位乘**可以只用单符号位**
> 答题的结果最好写为源码机器数

假设机器字长 n+1 位,数值部分占 n 位
符号位通过**异或**决定;数值部分通过被乘数和乘数绝对值的`n轮`**加法,移位**完成根据当前乘数中参与运算的位确定(ACC)加什么.**若当前运算为=1,则(ACC+[|x|])原;若=0,则(ACC)+0 (根据MQ中的最低位决定)**
每轮加法后ACC,MQ的内容统一**逻辑右移**

### 补码一位乘法

和原码一位乘法相似

进行 n 轮加法,移位,**最后再多来一次加法**

每次加法可能 **+0, +[x]补, +[-x]补** (根据当前MQ中的 最低位, 辅助位 来确定加的是什么)

> 辅助位 - MQ中的"最低位" = 1  时, **(ACC)+[x]补**
> 辅助位 - MQ中的"最低位" = 0  时, **(ACC)+0**
> 辅助位 - MQ中的"最低位" = -1 时, **(ACC)+[-x]补**

每次移位是 "补码的**算数右移**"

**符号位参与运算**

在补码运算中,MQ 的右边被扩展出一个辅助位, 辅助位初始为 0 .每次右移会使 MQ 的最低位顶替原本的辅助位(事实上 MQ 共 n+2位(一位符号位,一位辅助位,n位数值位))

由于寄存器的位数一般是统一的,所以 ACC 和 X 也会使用 n+2 位,因此采用双符号位进行补码运算,补位在高位,也就是最左边.

双符号位,正是 00 ,负是 11

补码的**算数右移**: **符号位不动,数值位右移,正数右移补 0, 负数右移补 1(符号位是什么就补什么)**

## 定点除法

规律: 忽略小数点,每确定一位商,进行一次减法,得到4位余数,在余数末尾补0,再确定下一位商.确定五位商即可停止(在机器字长5位的情况下)

### 原码除法: 恢复余数法

符号位单独处理: 符号位 = **Xs⊕Ys**

数值位取绝对值进行除法运算

计算机默认在MQ低位上商 1 ,如果搞错了再改上商 0 ,并"恢复余数"

ACC , MQ 整体"逻辑左移".ACC高位丢弃,MQ低位补0

### 原码除法: 加减交替法(不恢复余数法)

恢复余数法: 当余数为负时商 0 ,并 +|除数|, 再左移, 再-|除数|
加减交替法: 当余数为负时商 0,并左移, 再 +|除数|

### 补码除法: 加减交替法

- 符号位参与运算
- 被除数/余数,除数都采用双符号位

被除数和除数同号,则被除数减去除数
异号则被除数加上除数

余数和除数**同号**,商 **1** , 余数**左移一位减去除数**;
余数和除数**异号**,商 **0** , 余数**左移一位加上除数**

重复n次

**末位商恒定置为1**

## 浮点数运算

步骤: 

1. 对阶
2. 尾数加减
3. 规格化
4. 舍入(保留限定位数的尾数)
5. 判断溢出

# 第三章 指令系统

指令(又称作机器指令): 是指示计算机执行某种操作的命令,是计算机运行的最小功能单位

一台计算机的所有指令的集合构成该计算机的**指令系统**,也称为**指令集**

> 一台计算机只能执行自己指令系统中的指令,不能执行其他系统的指令
> 
> Eg: X86 架构,ARM 架构

一条指令就是机器语言的一个语句,它是一组有意义的二进制代码

一条指令通常要包括操作码字段和地址码字段

操作码(OP)  地址码(A)
用户的操作  对谁进行操作

## 指令地址

一条指令可能包含 0个,1个,2个....地址码
根据地址码的数目不同,可以将指令分为 零地址指令,一地址指令....

### 零地址指令 (OP  )

- 不需要操作数,如空操作,停机,关中断等指令
- 堆栈计算机,两个操作数隐含存放在栈顶和次栈顶,计算结果压回栈顶

### 一地址指令 (OP A1)

- 只需要单操作数,如加1,减1,取反,求补等 
  - 指令含义: OP(A1) -> A1 CPU首先从A1所指向的主存单元中取出相应的数据,然后对这个数据执行OP(操作符)所指明的相对应的操作,得到运算结果后把结果写回A1所指的存储单元
  - 完成一条指令需要三次访存: 取指令 -> 读A1 -> 写A1
- 需要两个操作数,但其中一个操作数隐含在某个寄存器中(如隐含在ACC中)
  - 指令含义: (ACC)OP(A1) -> ACC
  - 完成一条指令需要两次访存: 取指令 -> 读A1

> A1指某个主存地址,(A1)表示A1所指向的地址中的内容

### 二地址指令 (OP A1(目的操作数) A2(源操作数))

- 常用于需要两个操作数的算数运算,逻辑运算相关指令
  - 指令含义: (A1)OP(A2) -> A1
  - 完成一条指令需要四次访存: 取指令 -> 读A1 -> 读A2 -> 写A1

### 三地址指令 (OP A1 A2 A3(结果))

- 常用于需要两个操作数的算数运算,逻辑运算相关指令
  - 指令含义: (A1)OP(A2) -> A3
  - 完成一条指令需要四次访存: 取指令 -> 读A1 -> 读A2 -> 写A3

### 四地址指令 (OP A1 A2 A3(结果) A4(下址))

- 指令含义: (A1)OP(A2) -> A3, A4=下一条将要执行指令的地址
  - 完成一条指令需要四次访存: 取指令 -> 读A1 -> 读A2 -> 写A3

正常情况下: 取指令之后PC+1,指向下一条指令
四地址指令: 执行指令后,将PC的值修改为A4所指的地址


n位地址码的直接寻址范围 = 2^n

若指令总长度固定不变,则地址码数量越多,寻址能力越差

`指令字长`: 一条指令的总长度(可能会变)
`机器字长`: CPU进行一次整数运算所能处理的二进制数据位数(通常与ALU直接相关)
`存储字长`: 一个存储单元中的二进制代码位数(通常和MDR位数相同)

## 数据寻址

`数据寻址`: 确定**本条指令**的**地址码指明的真实地址**
`形式地址`: 指令中的地址码字段称为形式地址

### 寻址方式

`直接寻址`: 指令字中的形式地址A就是操作数的真实地址EA 
- 优点: 简单指令执行阶段仅访问一次主存不需要专门计算操作数的地址
- 缺点: A的位数决定了该指令的操作数的寻址范围,操作数的地址不易修改

`间接寻址`: 指定地址字段给出的形式地址不是操作数的真正地址,二世操作数有效地址所在的存储单位的地址,也就是操作数地址的地址,即EA=(A)
- 优点: 可扩大寻址范围,便于编制程序
- 缺点: 指令在执行阶段要多次访存

`寄存器寻址`: 在指令字中直接给出操作数所在的寄存器编号,即EA=Ri,其操作数在由Ri所指的寄存器内
- 优点: 在执行阶段不访问主存,之访问寄存器,指令字短且执行速度快,支持向量/矩阵运算
- 缺点: 寄存器价格昂贵,寄存器个数有限

`寄存器间接寻址`: 寄存器Ri中给出的不是一个操作数,而是操作数所在主存单元的地址,即EA=(Ri)
- 优点: 比一般的间接寻址快

`立即寻址`: 形式地址A就是操作数本身,又称为立即数,一般采用补码形式 `#` 表示立即寻址特征
- 优点: 指令执行阶段不访问主存,指令执行时间最短
- 缺点: A的位数限制了立即数的范围,如A的位数为n,且立即数采用补码时,克表示的数据范围为 (-2^n-1)~(2^n-1)-1

**偏移寻址**

以某个地址作为起点,形式地址视为"偏移量"

`基址寻址`: 以程序的起始存放地址作为"起点"
`变址寻址`: 程序员自己决定从哪里作为"起点"
`相对寻址`: 以程序计数器PC所指地址作为"起点"

### 基址寻址

将CPU中的`基址寄存器(BR,base address register)`的内容加上指令格式中的形式地址A.而形成操作数的有效地址,即EA=(BR)+A

> 采用专用寄存器BR作为基址寄存器
> OS中的**重定位寄存器**就是**基址寄存器**
> 也有计算机内部没有专门的BR,而是使用通用寄存器作为基址寄存器,这时指令中需要给出寄存器的编号.根据通用寄存器的数量可以判断需要指令中需要几个bit来表示,如有8个通用寄存器,指令中需要3位来表示.

### 变址寻址

有效地址EA等于指令字中的形式地址A与`变址寄存器IX(index register)`的内容相加之和,即EA=(IX)+A,其中**IX可为变址寄存器(专用)**,也**可用通用寄存器作为变址寄存器**

变址寻址也可和间址寻址一起使用,根据执行顺序的不同分为以下两种

`前变址`: 先进行变址寻址然后再进行间址寻址 EA=((IX)+A)
`后变址`: 先进行间址寻址然后再进行变址寻址 EA=(IX)+(A)

### 相对寻址

把`程序计数器PC`的内容加上指令格式中的形式地址A而形成操作数的有效地址,即EA=(PC)+A,其中**A是相对于PC**所指地址的**位移量**,可正可负,**补码表示**

## 操作类型
指令系统的完备性要求在设计指令系统时必须考虑制冷系统应提供哪些操作类型,对大多数制冷系统考察后得知,操作类型按功能分为以下几种

### 算数和逻辑运算指令

这类指令有 加(ADD)减(SUB)比较(CMP)乘(MUL)除(DIV)与(AND)或(OR)取反(NOT)取负(NEG)异或(XOR)加1(INC)减1(DEC)等

### 移位指令

这类指令有算数移位,逻辑移位,循环移位,半字交换等


### 传送指令

传送指令通常有寄存器之间的传送(MOV),从内存单眼读取数据到CPU寄存器的(LOAD),从CPU寄存器写数据到内存单元(STORE)等

### 串指令

对于字符串进行操作的指令


### 顺序控制指令

用来控制程序执行的顺序

### CPU控制指令

这类指令有停机,开中断,关中断,系统模式切换以及进入特殊处理程序等指令.

### 输入输出指令

这类指令用于CPU与外部设备交换数据或传送控制命令以及状态信息.

## 操作码编码

`定长指令字结构`: 指令系统中所有指令的长度都相等
`变长指令字结构`: 指令系统中各种指令的长度不等

`定长操作码`: 指令系统中所有指令的操作码长度都相同
`可变长操作码`: 指令系统中各指令的操作码长度可变

定长指令字结构 + 可变长操作码 -> 扩展操作码指令格式

扩展操作码举例:

指令字长为 16 位,每个地址码4位,前4位为基本操作码字段OP,另有三个4位长的地址字段 A1,A2,A3

4位基本操作码若全用于三地址指令,则有16条
但至少须将1111 留作扩展操作码之用,即三地址指令为 15 条

1111 1111 留作扩展操作码之用,二地址指令为15条

1111 1111 1111 留作扩展操作码之用,一地址指令为15条

零地址指令为16条

还有其他扩展操作码设计方法

> 在设计扩展操作码指令格式时,必须注意以下两点
>
> 1. **不允许短码是长码的前缀**,即短操作码不能与长操作码的前面部分的代码相同
> 2. 各指令的操作码一定不能重复

通常情况下,对频率较高的指令,分配较短的操作码;对使用频率较低的指令,分配较长的操作码,从而尽可能减少指令译码和分析时间

### 指令系统设计风格

**按操作数位置指定风格来分**

1. 累加器(Accumulator)型指令系统: 这类指令系统中,总是把其中一操作数隐含在累加器中
2. 栈(stack)型系统: 栈是一种采后后进先出(LIFO)或先进后出(FILO)取方式的特定存储区
3. 通用寄存器(General Purpose Register)型指令系统: 特点是采用通寄存器而不是累加器存放运算过程中所用的临时数据
4. Load/Store型指令系统: 也是使用通用寄存器而不是累加器来存放运过程中所用的零食数据,但显著特点是,只有取(load)指令和存数(Store)令才可以访问存储器,运算类指令不能访存.

目前通用寄存器型指令系统占主导地位.

**按指令格式的复杂度来分**

- CISC(复杂指令集计算机Complex Instruction Set Computer)
  - 指令系统复杂: 指令多,寻址方式多,指令格式多
  - 指令周期长: 大多数指令需要多个时钟周期才能完成
  - 采用微程序控制: 由于有些指令非常复杂,以至于无法用硬连线控制器来实现,而微程序控制器用软件设计思想实现硬件,可以实现对复杂指令的控制
  - 难以进行编译优化: 由于编译器可选指令序列增多,使目标代码组合增加,从而增加了目标代码优化的难度
- RISC(精简指令集计算机Reduced Instruction Set Computer)
  - 指令条目少: 只包含使用频度高的指令
  - 指令格式规整: 寻址方式少,指令格式少,指令长度一致
  - 采用load/store型指令设计风格
  - 采用流水线方式执行指令: 规整的指令格式有利于采用流水线方式执行,除了Load/Store指令外,其他指令都只需一个或小于一个时钟周期就可以完成,指令周期短
  - 采用大量通用寄存器: 编译器可将变量分配到寄存器中,以减少访存次数
  - 采用硬连线控制器: 指令少而规整使得控制器的实现变得简答,可以不用或少用微程序控制
  - 采用优化的编译系统: 指令数少有利于编译器的优化

## MIPS指令集与其汇编语言

### 指令格式和寻址方式

MIPS 是典型的RISC结构,按字节编址,采用32位定长指令字,操作码字段也是固定长度,没有专门的寻址方式字段,由指令格式确定各操作数的寻址方式

MIPS指令采用三地址指令格式,只有三种类型

- R - 型指令:
格式: OP  rs  rt  rd  shamt  funct

这类指令的两个操作数和结果都存放在寄存器中,其操作码OP为"000000",造作类型由funct字段指定.

寻址方式只有一种: 寄存器直接寻址

- I - 型指令:
格式: OP  rs  rt  立即数

如果是双目运算类指令,则将rs内容和立即数分别作为第一和第二源操作数,结果送rt

寻址方式有四种: 寄存器直接寻址,立即数寻址,相对寻址,基址或变址寻址

- J - 型指令
格式: OP  直接地址

主要是无条件跳转指令,指令中给出的是 26 位直接地址,只要将PC的高四位拼上26位直接地址,最后添两个"0"就可以得到32位的跳转目标地址

寻址方式只有一种: 变通的直接寻址

### MIPS中数据的表示

1. MIPS指令中的操作数可以是立即数,或是通用寄存器的内容,也可以是存储单元的内容
2. MIPS处理器提供了32 个 32位通用寄存器,因此寄存器编号占5位. 例如R型指令格式中的rs,rt,rd和I型指令格式中的rs,rt都是指通用寄存器.

> 0号寄存器总是为0 , 31号寄存器用于存放过程调用的返回地址

寄存器的汇编表示以`$`符号开始,可以使用名称(如$a0),也可以使用编号(如$4)

3. MIPS还提供了32个32位的单精度浮点寄存器,用汇编符号$f0~$f31表示,他们可以配对成16个64位浮点寄存器,用来表示64位双精度浮点数
4. MIPS中提供了两个乘商寄存器Hi和Lo,他们无需程序员在指令中显式给出.用32位的Hi和Lo可实现一个64位寄存器.
5. MIPS中用程序计数器PC指出下一条指令的地址
6. MIPS的存储器按字节编址.对于存储器数据,其操作数地址为32位,通过一个32位寄存器的内容加16位偏移量得到.其中,32位寄存器就是I型指令中的rs,16位偏移量就是I型指令中的16位立即数,通常是一个带符号整数,因而,存储器操作数可访问的地址空间大小为 2^32字节
7. MIPS采用大端方式(Big Endian)存放数据,数据要求按字边界对齐.只能通过Load/Store指令访问存储器数据.
8. 对于立即操作数,指令中给出的位数为16位,指令执行时,需要将其进行符号扩展或0扩展,变成32位操作数后才能参加运算.

常用的5类指令: 算数运算,存储访问,逻辑运算,条件分支,无条件转移

1. 算数类指令包括算数运算和逻辑运算指令,它们可以是R-型格式指令,也可以是I-型格式指令 如:"sub $s1,$s2,$s3"的含义为"$s1 = $s2-$s3"

I-型格式运算类指令的汇编表示有一个特点,就是指令操作助记符总是以i结尾,而且第二个源操作数一定是一个立即数 如:"andi $s1,$s2,100"的含义为"$s1 = $s2&100"

2. 逻辑运算指令中还包括了逻辑左移sll和逻辑右移srl 如:"srl $s1,$s2,10"的功能为 "$s1 = $s2>>10" 含义为: 将寄存器$s2中的内容逻辑右移10位后送至寄存器$s1中,逻辑右移操作的实现方式为: 低位移出,高位补0

3. 存储访问类的指令有两种,一种是装入(Load)指令,另一种是存储(Store)指令 如:"lw $s1,100($s2)"的含义是,将存储单元中一个32位数据装入到通用寄存器$s1中,存储单元的首地址为$s2的内容加上100,因此,这里$s1,$s2和100分别是I-型指令中的rs,rt和16位立即数

4. 条件分支类指令包括条件设置指令(如 slt)和分支指令(如 beq,bne).条件设置指令slt用于比较两个寄存器内容的大小,或者将某个寄存器内容与一个立即数比较,前者为R-型格式指令,后者为I-型格式指令 如: R-型格式指令 "slt $s1,$s2,$s3"用于判断寄存器$s2和$s3内容的大小,若"小于"则$s1=1,否则$s1=0

分支指令beq,bne分别用于判断两个寄存器内容是否相等,不等,并更具判断结果确定是否转移到目标指令处执行,他们都是I-型格式指令,转移目标地址采用相对寻址方式,即转移目标地址=(PC)+偏移量,指令的16位立即数就是偏移量

5. 无条件跳转指令包括j,jal和jr等几条指令,j指令执行后,将直接跳转到转移目标地址;jal指令用于过程调用,在其执行过程中,将先把当前PC的内容(jal指令下条指令的地址)作为返回地址,保存到31号寄存器$ra中,然后再跳转到转移目标地址;jr指令用于过程返回,该指令将从31号寄存器$ra中取出返回地址,将其作为转移目标地址进行跳转

## 程序的机器级表示

1. 选择结构的机器代码表示
2. 循环结构的机器代码表示

# 第四章 中央处理器

## 程序的执行概述

`指令周期`: CPU取出并执行一条指令的时间

CPU执行一条指令的大致过程是: 取指令,指令译码,计算源操作数地址并取操作数,执行数据操作,计算目的操作数地址并存结果,计算下条指令地址

1. 取指令: 取指令的操作就是从PC所指出的存储单元中取出指令送到指令寄存器(IR)
2. 指令译码: CPU根据不同的指令**操作码**译出不同的控制信号
3. 计算源操作数地址并取操作数: 若源操作数是寄存器中的数据,则直接从寄存器取数后,转到下一步进行数据操作.若是存储器操作数,则需要访问存储器.在访存之前,需要根据**寻址方式**确定源操作数地址计算方式
4. 数据操作
5. 目的操作数地址计算并存结果
6. 指令地址计算并将其送PC

## CPU的基本功能和基本组成

CPU的基本职能: 就是周而复始的执行指令,机器指令执行过程中的全部操作都是由CPU中的控制器控制执行的

CPU最基本部件: 数据通路(datapath)和控制部件(control unit)

### CPU的基本组成

1. `程序计数器(PC)`: PC又称指令计数器或指令指针寄存器(IP),用来存放即将执行指令的地址
2. `指令寄存器(IR)`: IR用以存放现行指令
3. `指令译码器(ID)`: 指令译码器对指令寄存器中的操作码部分进行分析解释,产生相应的译码信号提供给操作控制信号形成部件,以产生控制信号
4. `启停控制逻辑`: 启停控制逻辑控制时序型号的发生与停止,并实现对机器的启动与停机

5. `时序信号产生部件`: 该部件以时钟脉冲为基础,产生不同指令对应的周期,节拍,工作脉冲等时序信号,实现机器指令执行过程的时序控制
6. `操作控制信号形成部件`: 该部件综合时序信号,指令译码信号和执行部件反馈的条件标志(如 CF,SF,OF等),形成不同指令的操作所需要的控制信号
7. `总线控制逻辑`: 实现对总线传输的控制,包括对数据和地址信息的缓冲与控制,其中包括用来缓存数据信息的存储器数据寄存器MDR和用来缓存地址信息的存储器地址寄存器MAR.CPU对于存储器的访问通过总线进行,CPU将存储访问命令(即读写控制信号)送到控制线,将要访问的存储单元地址送到地址线,并通过数据线取指令或者与存储器交换数据信息
8. `中断机构`: 实现对异常情况和外部中断请求的处理 

### 打断程序正常执行的事件

1. 对指令操作码进行译码时,发现是不存在的"非法操作码"
2. 在访问指令或数据时,发现尧都区的指令和数据不在主存中
3. 在ALU中运算的结果发生溢出,或者整数除法指令的除数为0
4. 在执行的过程中,CPU外部发生了采样计时是按到,网络数据包到达网络适配器,磁盘完成数据读写等外部事件,要求CPU中止当前程序的执行,专去执行专门的外部事件处理程序

**基本概念**

`异常控制(中断机制)`: CPU除了能正常执行指令以外,还必须具有程序正常执行被打断时的处理机制
`中断机构`: CPU中相应的异常和中断处理逻辑

**异常和中断**

所有这些打断程序正常执行的事件被分为两大类: 异常和中断

`异常`: 异常指是由CPU内部的异常引起的意外事件

  1. 硬故障中断是由于硬连线路出现异常而引起的,如电源掉电,校验线路错等
  2. 程序性异常是由CPU执行某条指令而引起的发生在CPU内部的异常事件.如除数为0,溢出,断点,单步跟踪寻址错,访问超市,非法操作码,栈溢出,缺页,地址越界(段错误)等

`中断`: 程序执行过程中,若外设完成任务或发生某些特殊事件,设备控制器会向CPU发中断请求,要求CPU对这些情况进行处理.这类事件与执行的指令无关,由CPU外部的I/O硬件发出,所以,称为I/O中断或外部中断,需要通过外部中断请求线向CPU请求

## 数据通路基本结构和定时

`数据通路`: 指令执行过程中数据所经过的路径,包括路径上的部件
`执行部件或功能部件`: 数据通路中专门进行数据运算的部件

数据通路由控制部件发出的控制信号进行控制

指令执行用到的元件有两类: 组合逻辑元件(也称操作元件)和时序逻辑元件(也称状态元件或存储元件)

连接这些元件的方式有两种: 总线方式和分散连接方式

数据通路就是由组合逻辑元件和时序逻辑元件通过总线或分散方式连接而成的进行数据存储,处理和传送的路径

`操作元件`: 组合逻辑元件的输出只取决于当前的输入.若输入一样,其输出也一样.组合电路的定时不受时钟信号的控制,所有输入信号到达后,经过一定的逻辑门延迟,输出端的值呗改变,并一直保持其值不变,直到输入信号改变

`状态元件`: 状态元件具有存储功能,输入状态在时钟控制下被写到电路中,并保持电路的输出值不变,直到下一个时钟到达.输入端状态由时钟决定何时被写入,输出端状态随时可以读出

**数据通路的时序控制**

早期计算机的定时方式

通常采用机器周期,节拍和脉冲三级时序对数据通路操作进行定时控制

现代计算机的定时方式

现代计算机中,整个数据通路中的定时信号就是时钟信号,一个时钟周期就是一个节拍,CPU的主频就是时钟信号的频率

## 数据通路基本工作原理

单总线数据通路结构中,几种基本操作过程

1. 在通用寄存器之间传送数据

 如 要将寄存器R0的内容传送到寄存器Y,则对应的控制信号取值为: R0out=1,Yin=1,其余寄存器的Rin和Rout信号都为0

 通常称取值为1的Rin和Rout信号为有效控制信号,在描述控制信号取值时,止泄出有效控制信号,如"R0out,Yin"

2. 完成算数逻辑运算

  ALU运算的其中一个操作数来自Y寄存器,另一个操作数被置于总线上,运算结果被临时存放在寄存器Z中

  例如: 完成指令"R[R3] <- R[R1] + R[R2]"的有效控制信号如下

  R1out,Yin
  R2out,add,(Zin)
  Zout,R3in

任何时刻只能将一个寄存器的内容送到内总线,任何异步结束时结果要送到某个寄存器的输入端(即保存到寄存器).因此,该操作需要三个时钟周期(节拍)

3. 从内存单元读取一个字
早期的计算机,CPU和主存之间采用"异步"方式进行通信

假定需要在某条指令中实现操作R[R2] <- M[R[R1]] 控制信号序列如下

  R1out,MARin
  read,WMFC
  MDRout,R2in

4. 把一个字写入内存单元

  M[R[R2]] <- R[R1]

  R1out,MDRin
  R2out,MAR
  write,WMFC

`单周期处理器`是指其所有指令的指令周期都为一个时钟周期,`单周期数据通路`既是单周期处理器中的数据通路.在单周期数据通路中,所有操作都需要在一个时钟周期内完成

## 流水线方式下指令的执行

一条指令的执行可被分为若干个阶段,每个阶段都在相应的功能部件中完成,如果将各阶段看成相应的流水段,则指令的执行过程就构成了一条指令流水线. 如,假定一条指令流水线由以下5个流水段组成

取指令(IF): 根据PC的值从存储器取出指令并更新PC
指令译码(ID): 产生指令执行所需的控制信号
取操作数(OF): 读取存储器操作数或寄存器操作数
执行(EX): 对操作数完成指定操作
写回(WB): 将操作结果写入存储或寄存器

MIPS指令系统中最复杂的指令需要5个阶段完成操作,因此,MIPS指令流水线数据通路通常用一个五段流水线实现,其执行过程和功能段划分如下

取指(Ifetch): 取指令并PC加4(MIPS每条指令占32位,4单元)
译码/取数(Reg/Dec): 读取寄存器内容并对指令译码
执行(Exec): 进行算数运算或逻辑运算(包括传送操作)
访存(Mem): 存储器读数或写数据
写回(Write): 选择存入寄存器的结果并将其在寄存器输入端稳定保持一段建立时间

适合流水线的指令集特征

1. 指令长度尽量一致
2. 指令格式尽量规整,尽量保证源寄存器的位置相同
3. 采用Load/stor型指令风格
4. 为了便于以流水线方式执行指令,数据和指令在存储器中要"对齐"存放

## 控制器设计基本原理

`控制器`: 是整个CPU的指挥控制中心,也称为控制部件,控制逻辑或控制单元,作用是对指令进行译码,将译码结果和状态/标志信号,时序信号等进行组合,产生指令执行过程中所需要的控制信号

`控制信号`: 用于控制数据通路中信息的流动

根据不同的控制描述方式,可以有硬连线控制器和微程序控制器两种实现方式

`硬连线控制器`: 基本实现思路是,将指令执行过程中每个时钟周期所包含的控制信号取值看成一个状态.每来一个时钟，控制信号就会有一组新的取值，也就是一个新的状态，这样，所有指令的执行过程就可以用一个有限状态转换图来描述。实现时使用一个组合逻辑电路(一般为PLA电路)来生成控制信号,用一个状态寄存器记录状态之间的转换.因此控制器实际上就是一个有限状态机

理论上来说,控制器设计的过程很简单,主要步骤如下

1. 根据每条指令的功能,确定每条指令的执行步骤,画出指令执行的流程图
2. 给出每条指令在每个步骤中各个控制信号的取值,并在表中列出
3. 根据指令和控制信号的关系,写出每个控制信号的逻辑表达式
4. 根据逻辑表达式,画出控制器的逻辑电路

优点: 控制器速度快,适合于实现简单,规整的指令系统,如MIPS指令系统
缺点: 多输入/多输出,复杂,巨大的网状逻辑,对于CISC这种复杂指令系统来说,由于其控制逻辑机器复杂,实现难度非常高,不易维护,扩充,修改

`多周期数据通路`: 对于总线结构数据通路,需要多个时钟周期才能完成一条指令的执行.通常把这种一个指令周期包含多个时钟周期的数据通路称为多周期数据通路.

`微程序控制器`: 基本实现思路是,仿照程序设计方法,将每条指令的执行过程用一个**微程序**来表示,将指令执行过程中每个时钟周期所包含的控制信号取值看成是由多个微命令组成的一条**微指令**

`微程序`: 每条指令的执行过程
`微指令`: 指令执行过程中每个时钟周期所包含的控制信号取值看成是由多个微命令组成的一条**微指令**
`微命令`: 每个控制信号对应一个微命令
`微地址`: 微指令所在的存储单元的地址

一个微程序由若干条微指令组成.每个控制信号对应一个微命令,控制信号取不同的值,就发出不同的微命令

`控制存储器(CS)`: 在CPU内部,用于存放微程序的**只读存储器**,简称控存

微程序的定序器的实现有计数器法和断定法(下地址字段法)两种

`计数器法`: 使用专门的微程序计数器μPC,将下条微指令地址隐含的存放在μPC中.顺序执行时,根据μPC + 1 -> μPC得到下条微指令的地址;执行转移时,在当前的微指令后添加一条"转移微指令",并在微指令中添加专门的"转移控制字段",将"转移微指令"或"转移控制字段"中的控制信息送到微指令地址发生器,与相应的指令操作码以及条件码等组合,生成转移微地址送μPC

`断定法`: 在微指令中增加一个下地址字段,在该字段中直接给出下条微指令地址,因此也称为下地址字段法

采用软件设计思想,不管指令多复杂,只要事先将其包含的操作所用的控制信号存储在控存中,就可以在指令执行时将控制信号取出,以控制指令执行.

CISC指令系统大多采用微程序控制器实现,不过,因为微程序控制器在每个时钟周期都要访问控制存储器,因此指令执行速度比较慢

## 指令流水线中的冒险处理

`流水线冒险(hazard)`: 指令序列在流水线中执行时,可能会遇到一些情况,使流水线无法正确,按时执行后续指令,从而引起流水线阻塞或停顿(stall)

类型:

`结构冒险`: 也称为硬件资源冲突,引起结构冒险的原因在于同一个部件同时被不同指令所用,也就是硬件资源竞争造成

解决策略有两种:

1. 规定一个部件每条指令只能使用一次,且只能在特定阶段使用
2. 通过设置多个独立的部件来避免资源冲突

`数据冒险`: 也称为数据相关,原因在于后面指令需要读取前面指令的运算结果时,前面指令的结果还没有写入寄存器中

解决策略有以下: 

1. 最简单是由编译器在数据相关的指令之间加若干nop指令(即空操作指令,除了修改PC外什么操作都不做)
2. 采用数据转发技术,数据通路中一旦产生运算结果或一旦存储器读出数据,就把他们通过一条旁路直接送到相关后续指令在执行阶段的ALU输入端
3. 对于无法通过转发来解决,可以在load指令后面加一条nop指令;也可以通过硬件阻塞的方式来延迟load指令随后的一条指令的执行,此时流水线阻塞一个时钟周期,程序执行时间延长一个时钟周期
4. 对于关于寄存器$8的数据相关问题,则可以通过对于通用寄存器的读写操作进行特殊处理

`控制冒险`: 正常情况下,指令在流水线中总是按顺序执行,当遇到改变指令执行顺序的情况时,流水线中指令的正常执行会被阻塞.这种由于发生了指令执行顺序改变而引起的流水线阻塞称为控制冒险

## 高级流水线基本原理

高级流水线技术充分利用指令级并行( Instruction-level parallelism ,简称为ILP )来提高流水线的性能。有两种增加指令级并行的策略。

`超流水线(super-pipelining)技术`: 通过增加流水线级数来时更多的指令同时在流水线中重叠执行

`多发射流水线技术`: 通过同时启动多条指令独立运行来提高指令并行性

实现多发射流水线必须完成以下两个任务

`指令打包`: 指令打包任务就是将能够并行处理的多条指令同时发送到发射槽中。

`冒险处理`: 指令打包依赖于推测结果，有可能结果时错误的，所以需要推测错误检测和回退机制

## 异常和中断

`异常`通常是由程序错误引起的，是计算机系统内部的问题
`中断`是由外部事件(I/O设备)引起的，是计算机系统与外部世界的交互

有时候为了强调异常是CPU内部执行指令时发生,而中断时CPU外部的I/O设备向CPU发出的请求,特称异常为`内部异常`,中断为`外部中断`

处理过程和实现机制基本相同

### 异常的分类

内部异常分为三类

`故障(fault)`,`陷阱(trap)`,`中止(abort)`

`故障`: 故障是在引起故障的指令被启动后但未执行结束时CPU检测到的一类与指令相关的意外事件,有些可以恢,有些不能

例子

1. 对于像溢出和非法操作码等这类故障,无法恢复
2. 对于除数为0的情况,根据是定点除法还是浮点除法指令有不同的处理方式
3. 对于页故障(page fault),对应的页故障处理程序会根据不同的情况进行不同的处理

`陷阱`: 也成为自陷或陷入,是预先安排的一种"异常事件",就像"陷阱"一样 ,可以用来进行系统调用

`终止`: 在指令过程中发生了非常严重的错误如控制器出现问题

### 中断的分类

`可屏蔽中断`: 指通过可屏蔽中断请求线INTR向CPU进行请求的中断,主要来自于I/O设备,CPU可以通过中断控制器中设置相应的屏蔽字来屏蔽或不屏蔽

`不可屏蔽中断`: 是非常紧急的硬件故障,通过不可屏蔽中断请求线请求

### 异常和中断的相应过程

`保护断点和程序状态`: 对于不同的异常事件,其返回地址(即断点)不同

`关中断`: 设置一种机制来精致在处理异常或中断时再响应新的异常或中断

`识别异常和中断事件并转相应处理程序执行`

# 存储器的层次结构

## 存储器概述

按存储元件分: 半导体存储器,磁表面存储器,光盘存储器

按存取方式分类: 随机存取存储器,顺序存取存储器,直接存取存储器

按信息的可更改性分类: 读写存储器,只读存储器

按断电后信息的可保存性分类: 非易失性存储器,易失性存储器

## 主存储器的组成和基本操作

`存储元(位元)`: 存储一位二进制代码
`存储单元(编址单位)`: 由多个存储元构成,可以存储多位二进制代码
`存储芯片`: 由多个存储单元组成的存储阵列构成
`存储器`: 由多个存储芯片构成
`存储容量`: 存储单元的位数与存储单元个数的乘积

写操作,读操作

`最大寻址范围`: 地址线的位数决定了主存地址空间的最大可寻址范围
`存储器容量`: 指存储器能存放的二进制位数或字数
`存取时间`: 一般用读出时间TA以及写入时间TW来描述
`存储周期`: 存储器进行一次读写操作所需要的全部时间
`存储器带宽`: 表示存储器被连续访问时,可以提供的数据传输速率,通常用每秒钟传送信息的位数来衡量
`存储器的价格`: 总价格C或每位价格c来表示
`存储器速度`: 可用存取时间,存储周期或带宽表示

**存储器的层次化结构**

寄存器
高速缓存
主存储器
辅助存储器
海量后备存储器

## 半导体随机存取存储器

### 基本存储元件

1. 六管静态MOS管存储元件 SRAM 静态RAM利用六管静态MOS管组成的双稳态电路来保存信息
2. 单管动态MOS管存储元件 DRAM 动态RAM利用MOS管的栅极电容Cs来保存信息。

静态存储元件和动态存储元件的比较

SRAM存储元件所用MOS管多,占硅片面积大,功耗大,集成度低,但无需刷新,也无需读后再生,读写速度快,适合作高速小容量的半导体存储器
DRAM存储元件所用MOS管少,占硅片面积小,功耗小,集成度高,但必须刷新,也需要读后再生,读写速度相对SRAM慢很多,适合做慢速大容量的主存

### 半导体RAM芯片

由 存储体,I/O读写电路,地址译码和控制电路等部分组成.

`存储体`: 存储体时存储单元的集合
`地址译码器`: 用来将地址转换为译码输出线上的高电平,以便驱动相应的读写电路 译码方式有单译码和双译码两种,容量较大的存储芯片一般采用双译码
`存储字`: 有些芯片的存储阵列采用三维结构,用多个位平面构成存储整列,不同位平面在相同行和列的交叉点上的多位构成一个存储字,被同时读出或写入
`驱动器`: 在双译码结构中,一条X方向的选择线要控制在其上的各个存储单元的字选择先,负载叫法,因此需要在地址译码器后加驱动电路
`I/O控制电路`: 用与控制被选中单元的读出或写入,具有放大信息的作用
`读/写控制信号`: 根据CPU给出的时读命令还是写命令,控制被选中存储单元进行读取或者写入

### SDRAM芯片技术

传统DRAM与CPU之间采用异步交换数据

SDRAM读写接受系统时钟控制,与CPU采用同步的方式交换数据

DDR SDRAM芯片技术采用两位预读取功能,能够在一个时钟内传送两次数据

DDR2 SDRAM能进行4位预取

DDR3 SDRAM能进行8位预取

## 存储芯片的扩展以及其与CPU的连接

### 内存条和内存插槽

CPU通过其芯片内的总线接口部件(总线控制逻辑)与系统总线相连,然后再通过总线之间的I/O桥接器,存储器总线连接到主存

### 存储芯片的扩展

扩展的步骤

- 确定需要的芯片数量
- 确定组织方式
- 画出地址分配图以及写出片选逻辑
- 画出存储器逻辑图或存储器与CPU的连接图

例题: 用8K x 1位的SRAM芯片构成8K x 8位存储器，地址线为A15(高)~A0(低)

1. 需要几片这种存储芯片
2. 存储器共需要几位地址?是哪几位地线
3. 加至各个芯片的地址线是哪几位

解:

1. 8K / 8K * 8bit / 1bit = 8(片)

```
8k   8bit
-- x ---- = 8
8k   1bit
```

2. 存储器是8kx8位, 8K = 2^3 * 2^10 = 2^13 ,存储器需要13位地址,即A12~A0
3. 存储芯片是8kx1位, 8K = 2^3 * 2^10 = 2^13 ,存储器需要13位地址,即A12~A0

例题: 用8K x 8位的SRAM芯片构成32K x 8位存储器，地址线为A15(高)~A0(低)

1. 需要几片这种存储芯片
2. 存储器共需要几位地址?是哪几位地线
3. 加至各个芯片的地址线是哪几位
4. 永远产生片选信号的地址线是哪几位(译码法)

解:

1. 32K / 8K * 8bit / 8bit = 4(片)
2. 存储器是32kx8位, 32K = 2^5 * 2^10 = 2^15 ,存储器需要15位地址,即A14~A0
3. 存储芯片是8kx8位, 8K = 2^3 * 2^10 = 2^13 ,存储器需要13位地址,即A12~A0
4. 15 - 13 = 2 是A13,A14  2-4

### 连续编址和交叉编址

`多模块存储器`: 通常把由多个独立并行工作的多个存储模块构成的存储器称之

根据不同的编址方式,多模块存储器分为连续编址和交叉编制两种

`连续编址方式`: 连续编址的多模块主存储器中，主存地址的高位表示模块号(或体号) ,低位表示模块内地址(或体内地址)因此,也称为按高位地址划分模块方式，地址在模块内连续。

`交叉编制方式`: 交叉编址存储器中，主存地址的低位表示模块号,高位表示模块内地址,因此，也称按低位地址划分模块方式。若有m个存储模块,则每个模块按"模m"交叉方式编址称为m体交叉编址方式。

## 半导体只读存储器和FLASH

