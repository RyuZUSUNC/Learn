# 绪论

## 软件工程概念的提出与发展

`软件危机`: 20世纪60年代以来,随着计算机的广泛应用，软件生产率、软件质量满足不了社会发展的需求，成为社会、经济发展的制约因素，人们通常把这些现象称为软件危机。

++**软件工程概念的提出**

软件工程概念的提出，其目的是**倡导以工程的`原理`、`原则`和`方法`进行软件开发**,以期解决出现的`软件危机`。

`软件工程`这一术语首次出现在**1968**年的**NATO (北大西洋公约组织)**会议上!

**软件工程的定义**

软件工程是应用**计算机科学理论**和**技术以及工程管理原则和方法**，按预算和进度实现满足用户要求的软件产品的**工程**，或以此为研究对象的**学科**。

++**软件工程的发展**

**20世纪60年代末到80年代初**

主要成果: 提出**瀑布模型**、开发了诸多**过程式语言**(如C语言、Pascal语言) 和**开发方法**(如Jackson方法、结构化方法)、开发了一些**支持工具**(调试工具、测试工具)等。

特征: 前期主要研究**系统实现技术**，后期开始关注**软件质量**和**软件工程管理**。

++**20世纪80年代以来**

主要成果: 提出**软件生存周期过程**、开展**计算机辅助工程(CASE)** 、**面向对象语言**(如Smalltalk、C++) 、提出**面向对象软件开发方法**等。

特征: 开展了一系列有关软件生产技术，特别是**软件复用技术**和**软件生产管理**的研究和实践。

## 软件开发的本质

`计算机软件`一般是指计算机系统中的**程序及其文档**。

`程序`是对计算机任务的**处理对象和处理规则的描述**。

`文档`是为了理解程序所需的**阐述性资料**。

**软件开发的本质**

软件开发的**目标**是将**问题域**中的概念映射为**运行平台**层面上的概念,把问题域中的处理逻辑映射为运行平台层面上的处理逻辑

软件开发就是要**弥补**问题域与运行平台之间的**距离**，从而在二者之间直接进行映射

概念:不同**抽象层术语**之间的`映射`，以及不同`抽象层处理逻辑`之间的“映射”实现这一一映射的基本途径:`系统建模`。

内容:
一是如何**实现**这样的映射，这是**技术**层面的问题。
二是如何**管理**这样的映射，以保障映射的有效性和正确性,这是**管理**层面的问题。

++**模型**

`模型`,简单地说，是**待建系统的任意抽象**，其中包括所有的基本能力、特性或其他一些方面，而没有任何冗余的细节。

进一步说，模型是在特定意图下所确定的角度和抽象层次上对**物理系统的描述**，通常包含对该系统边界的描述、对系统内各模型元素以及它们之间关系的语义描述。

在软件开发中，软件系统模型大体.上可分为两类:**概念模型**和**软件模型**。(在软件开发领域，分层的**基本动机**是为了控制开发的复杂性。)

`概念模型`在需求层.上创建的系统`概念模型`是对客观事物系统的抽象，即标识要解决的问题，或称问题定义。

`软件模型`设计模型、部署模型、实现模型

# 软件需求与软件需求规约

## 需求与需求获取

软件需求是任何软件工程项目的**基础**

`需求`定义

一个需求描述了待开发产品/系统**功能上的能力**、**性能参数**或**其他性质**例如:

- 系统必须实现"某-业务” 功能，并有能力支持1000个以上的并发用户,平均响应时间应该小于1s,最大响应时间应小于5s。
- 系统必须有能力存储连续100天操作所产生的事务。

对于单一一个需求， 必须具有5个基本性质:

- `必要的`(Necessary) :该需求是用户所要求的;
- `无歧义的`(Unambiguous) :该需求只能用一种方式解释;
- `可测的`(Testable) :该需求是可进行测试的; 
- `可跟踪的`(Traceable) :该需求可从一个开发阶段跟踪到另一个阶段;
- `可测量的`(Measurable) :该需求是可测量的。

++**需求分类**

功能需求: 规约了系统或系统构建必须执行的能力,是整个需求的**主体**
非功能需求: 性能需求,外部接口需求,设计约束,质量属性

++**需求发现技术**

初始发现需求的常用技术包括以下几个:

`自悟`(Introspection): 需求人员**把自己作为系统的最终用户**审视该系统并提出问题，"如果是我使用这一系统,则我需要....”。
`交谈`(Individual Interview): 为确定系统应该提供的功能，需求人员通过**提出问题/用户回答**这一方式，直接询问用户需要的是一个什么样的系统。

`观察`(Observation) :通过**观察用户**执行其现行的任务和过程，或通过观察他们如何操作与所期望的新系统有关的现有系统，了解系统运行的环境，特别是了解要建立的新系统与现存系统、过程以及工作方法间必须进行的交互。
`小组会`(Group Session) :举行客户和开发人员的**联席会议**，与客户组织的一些代表共同开发需求。
`提炼`(Extraction) :**复审技术文档**，并提取相关信息。

## 需求规约

`需求规约`是一个软件产项/产品/系统**所有需求陈述的正式文档**，它表达了一个软件产品/系统的概念模型。

`需求规约`一般需要满足以下4个基本性质:

- 重要性和稳定性程度(Ranked for Imortance and Stability) :按需求的重要性和稳定性对需求进行分级，如基本需求、可选需求和期望需求; 
- 可修改的(Modifiable) : 在不过多地影响其他需求的前提下，可以容易地修改一个单一需求;
- 完整的(Complete) : 没有被遗漏的需求;
- 一致的(Consistent) :不存在互斥的需求。

+++**需求规约的格式**

```
1.引言
 1.1目的
 1.2范围
 1.3定义，缩略语
 1.4参考文献
 1.5概述
2.总体描述
 2.1产品概述
 2.2产品功能
 2.3用户特性
 2.4约束
 2.5假设和依赖
3.特定需求
附录
索引
```

++**需求规约的表达**

在实际工程中，需求规约的表达主要存在3种不同的风格:

**非形式化的需求规约**:

以一种自然语言来表达需求规约，如同使用一种自然语言写了一篇文章.适用于规模比较小的、复杂程度不大高的小型软件项目，或在获取SRS(草案)时使用的。

**半形式化的需求规约**:
以半形式化符号体系(包括术语表、标准化的表达格式等)来表达需求规约;一些有能力的组织针对大型复杂项目，在开发需求文档时往往使用系统化的需求获取、分析技术和工具。

**形式化的需求规约**: 
以一种基于良构数学概念的符号体系来编制需求规约，一般常伴有解释性注释的支持。主要针对质量(特别是安全性)要求比较高的软件产品/系统或其中某一部分。

++**需求规约的作用**

需求规约的作用可概括为以下4点:

- 需求规约是软件开发组织和用户之间一份事实上的**技术合同书**,是**产品功能**及其**环境的体现**。
- 对于项目的其余大多数工作,需求规约是一个**管理控制点**。
- 对于产品/系统的设计，需求规约是一个**正式的、 受控的起始点**。
- 需求规约是创建产品验收测试计划和用户指南的基础，即基于需求规约-般还会产生另外两个文档----**初始测试计划**和**用户系统操作描述**。

# 结构化方法

## 结构化需求分析

在进行软件系统/产品的需求工作中，通常面临3大挑战:

◆问题空间理解; 
◆人与人之间的通信;
◆需求的变化性。

应对三大挑战的软件开发方法:

结构化方法、面向数据结构方法、面向对象方法等。

`数据流`: 在结构化分析方法中，数据流是数据的流动。在图中使用箭头描述

`加工`: 加工是**数据**的**变换单元**，即它接受输入的数据，对其进行处理，并产生输出;在使用中，一般给出标识，且标识为动宾结构。在图中使用圆圈描述

`数据存储`: 在结构化分析方法中，**数据存储**是**数据**的**静态结构**。在图中使用双横线描述

`数据源和数据潭`: **数据源**是**数据流**的**起点**;**数据遭**是**数据流**的**归宿地**。数据流和数据潭是系统之外的**实体**，可以是**人**。**物**或者**其他软件系统**。在图中使用方框描述

需求分析的**首要任务**是**建立系统功能模型**;

`DFD图(数据流图)`: **表达功能模型的工具**

DFD图是一种`描述数据变换`的图形化工具，是一种表达`待建系统功能模型`的工具。

**建模过程**

自顶向下,功能分解

- 建立`系统环境图`，确定系统语境
- 自顶向下，`逐步求精`，建立`系统的层次数据流图`
- 定义`数据字典`
- 描述`加工`

数据结构符号

```
= : 定义为
{}: 重复
+ : 顺序
m...n:子界
[|] : 选择
```

`判定表`: 是用以描述加工的一种工具,通常用来描述一些不易用自然语言表达清楚或需要很大篇幅才能表达清楚的加工

- 适用于输入数据和输出数据之间的逻辑关系**比较复杂**的情况。
- 通常用于描述不易用**自然语言**表达清楚或需要大篇幅才能表达清楚的加工。
- 适用于当描述的加工由**一组操作**组成，且是否执行某些操作或操作的执行情况取决于一组条件时。

通常由四个区组成

1. 条件类别
2. 条件组合
3. 操作
4. 操作执行

`判定树`: 适用于输入数据和输出数据之间的逻辑关系**比较复杂**的情况。

`结构化自然语言`: 适用于输入数据和输出数据之间的逻辑关系**比较简单**的情况。

结构化自然语言的语法有内、外两层:

➢外层语法描述操作的控制结构，如顺序、选择、循环等;
➢内层语法没有什么限制，-般使用自然语言描述。

特点:

➢没有形式语言那样严格;
➢简单易懂,又避免了自然语言结构松散的缺点。

**`抽象`**和**`分解`**是结构化分析方法采用的两个**基本手段**:

需求阶段的主要任务:需求**发现**、需求**分析**和需求**验证**，最终形成系统的**软件需求规格说明书**。

## 结构化设计

结构化设计的**主要任务**:在`需求分析`的基础上，定义满足需求所需要的结构，即针对给定的问题，给出该问题的软件解决方案,确定“怎么做”的问题。

为控制软件设计的复杂性，结构化设计进一步分为`总体设计`和`详细设计`!

`总体设计`将系统分解成一个个“黑盒子”，`详细设计`描述其细节。

**目标及表示**

`模块`: 软件中具有特定标识的独立成分;是执行一个特殊任务的一个过程以及相关的数据结构。
`模块调用`: 模块之间的一种使用关系。

基本任务:

把系统的**功能**需求**分配**到一个特定**软件体系结构**中，建立系统的模块结构,只声明其作用或功能。

`结构图`是一种描述软件**宏观结构**的图形化工具

较高层级: 控制(或管理)模块
较低层级: 从属模块

**总体设计工具**

- 模块结构图
- 层次图(H图)
- HIPO图(H图+IPO图)

**总体设计步骤**

- 系统的DFD图
- 初始的模块结构图 [基于"高内聚低耦合"这一软件设计原理模块化]
- 最终的、可供详细设计使用的模块结构图

待建系统的DFD图可以分为:

`变换型数据流图`: 具有较明显的输入部分和变换(或称主加工)部分之间的界面变换部分和输出部分之间界面的DFD图

`事务型数据流图`
数据到达一个加工T,该加工T根据输入数据的值，在其后的**若干动作序列**(或称一个事务)中**选出一个**来执行。

处理T称为事务中心，完成以下任务:
- 接收输入数据;
- 分析并确定对应的事务;
- 选取与该事务对应的一条活动路径。

事务型数据流图所描述系统的数据处理模式为"**集中一发散**”式。

结构化设计方法基于“**自顶向下，功能分解**”的基本原则，针对两种不同类型的数据流图，分别提出**变换设计**和**事务设计**。

`变换设计`

目标:将**变换型**数据流图映射为**模块结构图**

`事务设计`

目标:将**事务型**数据流图映射为**模块结构图**

总体设计分为3阶段:
第一阶段:`初始`设计(将给定的**数据流图转换为**初始的**模块结构图**)
第二阶段:`精化`设计(“**高内聚低耦合**”,**精化**模块结构图,设计**数据结构**和**接口**)
第三阶段:`复审`阶段(对高层软件结构进行复审,精化)

**变换设计步骤**

将**变换型**数据流图映射为**模块结构图**

变换设计的基本步骤: 

- 设计准备 复审并精化系统模型
- **确定输入、变换、输出这三部分之间的边界**
- 第一级分解 系统模块结构图顶层和第一层的设计
- 第二级分解 自顶向下， 逐步求精

**事务设计步骤**

将**事务型**数据流图映射为**模块结构图**

事务设计的基本步骤:

- 设计准备 复审并精化系统模型
- **确定事务处理中心**
- 第一级分解 系统模块结构图顶层和第一层的设计
- 第二级分解 自顶向下， 逐步求精

变换设计与事务设计的**区别**及**联系**

◆区别:分别从两者的**目的**、**组成**、**任务**来看。

变换设计:
1. 将变换型数据流图映射为模块结构图;
2. 组成:获取数据、变换数据(**核心**)和输出数据;
3. 设计一个主控模块来协调和控制其他模块,比较机械。

事务设计:
1. 将事务型数据流图映射为模块结构图;
2. 事务中心需完成3个任务:接收数据、分析并确定事务和选取活动路径。

◆联系:以变换设计为主，事务设计为辅。


实践中，一个大型的软件系统一-般是变换型流图和事务型流图的**混合结构**。

➢在软件总体设计中，通常以**变换设计为主，事务设计为辅**，进行结构设计;
➢先利用**变换设计**，把软件系统分为**输入、中心变换和输出**3个部分，设计.上层模块;
➢再根据各部分DFD图的结构特点，适当地利用**变换设计**和**事务设计**进行细化，得到初始模块结构图;
➢最后按**高内聚低耦合**的原则，对初始的模块结构图进行精化，得到最终模块结构图。

**模块化及启发式规则**

`模块化`: 即把一个待开发的软件分解成若干简单的、具有高内聚低耦合的模块的过程。[模块 =接口+模块体]

如何将系统分解成软件模块: "分而治之” 和”抽象”

如何设计模块:伪码、问题分析图PAD、N-S图

**结构化软件设计**是一种典型的模块化方法, 而模块化是系统设计基本原理/原则之一!

`耦合`: **不同模块之间**相互依赖程度的度量
`内聚`: 一个**模块内部各成分之间**相互关联程度的度量

`模块化的目标`:基于模块“高内聚低耦合”的原则，提高模块**独立性**;衡量模块独立性的**指标**:耦合和内聚。

`内容耦合`一个模块**直接修改**或**操作**另一个模块的数据。**耦合程度最高,尽量避免使用**

`公共耦合`两个或两个以上的模块共同引用一个**全局数据项**。

`控制耦合`一个模块通过**接口**向另一个模块传递**一个控制信号** (如开关、标志) , 接收信号的模块根据信号值进行适当的动作。

`标记耦合`模块A通过**接口**向两个模块B和C传递一个**公共参数**, 称模块B和C间存在一个标记耦合。

`数据耦合`模块之间通过**参数**来传递数据。**耦合程度最低， 存在普遍**

设计原则:

- 尽量**使用数据耦合**
- **少用**控制耦合
- **限制**公共耦合的范围
- 尽量**避免**使用内容耦合

`高内聚`: 一个模块中各部分之间存在着`很强的依赖`。
`低内聚`: 一个模块中各部分之间存在`较少的依赖`。

`偶然内聚`: 模块各成分间无关系(**最低程度,最高错误率**)
`逻辑内聚`: 模块各成分逻辑上相关
`时间内聚`: 各成分因时间相关联
`过程内聚`: 模块各处理按次序执行功能通过**研究流程图**确定模块的划分
`通信内聚`: 模块各成分都操作或生成同一数据集
`顺序内聚`: 一个成分的输出作为另一成分的输入
`功能内聚`: 模块对完成功能充分必要(最理想,最高内聚程度)

**模块化及启发式规则**

■启发式规则.

实现高内聚低耦合的启发式规则:

1. 改进软件结构,提高模块独立性;
2. 力求模块规模适中; (不超过60行)
3. 力求**深度**、**宽度**、**扇出**和**扇入**适中。(扇出3或4)

`深度`: 控制的层数，粗略标志一个系统的规模和复杂程度。
`宽度`: 同一个层次上模块总数的最大值(受扇出影响)。
`扇入`: 表明有多少个上级模块直接调用它。
`扇出`: 一个模块直接调用的下级模块数目。

设计得很好的软件结构:

➢顶层模块:扇出较大;
➢中间层模块:扇出较小;呈现“葫芦"形状
➢底层模块:扇入较大;

注意:模块的扇入大，即共享该模块的上级模块数目越多,可`提高软件的复用性`!

实现高内聚低耦合的启发式规则;

1. 尽力使模块的`作用域`在其`控制域`之内;
2. 尽力降低模块接口的复杂度;
3. 力求模块功能可以预测。

`控制域`: 模块本身以及所有直接或间接从属于它的模块集合。
`作用域`: 受该模块内一个判定所影响的所有模块的集合。

**目标和任务**

`目标`:将总体设计阶段产生的系统**高层结构**映射为以这些术语所表达的**低层结构**，即系统的最终结构。
`任务`:具体描述模块结构图中的每一个模块， 即给出**实现模块功能的实施机制**，包括一组例程和数据结构，从而精确地定义了满足需求规约的结构。

**结构化程序设计**
结构化程序设计方法是一种基于结构的编程方法, 采用**顺序结构**、**选择结构**以及**重复结构**进行编程,每一结构只允许一个**入口**和一个**出口**。

>实际上，用顺序结构和循环结构完全可以实现选择结构;理论上最基本的控制结构只有两种:顺序结构、循环结构。

**详细设计工具**

**图形、表格、语言**

- 程序流程图(程序框图)
- 盒图(N-S图)
- PAD图
- 类程序设计语言PDL

**程序流程图(程序框图)**

优点: 对控制流程的描绘很直观，便于初学者掌握。
缺点: 不是一种逐步求精的工具、影响甚至破坏好的系统结构设计、不宜表示数据结构。

使用的主要符号:顺序结构、选择结构、循环结构。

**盒图(N-S图、矩形结构)**

支持“自顶向下逐步求精”

**PAD图(问题分析图)**

二:维树形结构图;自上而下、从左向右

**类程序设计语言( PDL或伪码)**

混合"语言"

- 借用某种结构化程序设计语言的关键字作为语法框架; 
- 使用某种自然语言的词汇。

**概要设计规约** 指明高层软件体系结构

1.系统环境，包括硬件、软件接口、人机界面、外部定义的数据库等。
2.软件模块的结构，包括模块间的接口及设计的数据流和主要数据结构等。
3.模块描述，包括模块接口定义、模块处理逻辑及必要的注释等。
4.文件结构和全局数据文件的逻辑。
5.测试需求等。

**详细设计规约**对软件各成分内部属性的描述

- 各处理过程的算法
- 算法所涉及的全部数据结构的描述。
